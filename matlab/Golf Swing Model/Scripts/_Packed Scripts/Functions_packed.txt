%%% MATLAB PROJECT PACKER - v1.0 %%%
%%% Source Folder Base: C:\Users\diete\MATLAB Drive\_Golf Swing Model Rebuild\_Rebuilt Assembly\Functions %%%
%%% Pack Time: 03-May-2025 08:48:27 %%%

%%% START FILE: IdentifyLoggedSignals.m %%%
% Identify Logged Signals (Option to Delete)

% Load model if not already open
if ~bdIsLoaded('GolfSwing3D_KineticallyDriven')
    load_system('GolfSwing3D_KineticallyDriven');
end

% Find all lines with signal logging enabled
loggedLines = find_system('GolfSwing3D_KineticallyDriven', 'FindAll', 'on', 'Type', 'line', 'SignalLogging', 'on');

% % Disable signal logging for each
% for i = 1:length(loggedLines)
%     set(loggedLines(i), 'SignalLogging', 'off');
% end
%
% % Save the model (optional)
% save_system('GolfSwing3D_KineticallyDriven');

fprintf('Logged Signals', loggedLines);

%%% END FILE: IdentifyLoggedSignals.m %%%

%%% START FILE: calculatePathVectors3D.m %%%
function [BASEQ, ZTCFQ, DELTAQ] = calculatePathVectors3D(BASEQ, ZTCFQ, DELTAQ)
% CALCULATEPATHVECTORS3D Computes 3D path vectors for Clubhead and Midpoint Hand.
%   [BASEQ, ZTCFQ, DELTAQ] = CALCULATEPATHVECTORS3D(BASEQ, ZTCFQ, DELTAQ)
%   calculates the 3D displacement vectors between consecutive time steps
%   for the Clubhead (CH) and Midpoint Hand (MP) based on their position
%   coordinates in the input tables. The calculated vectors (CHPx, CHPy,
%   CHPz, MPPx, MPPy, MPPz) are added as new columns to the respective tables.
%
%   This function operates on tables that are expected to be on a uniform
%   time grid, typically the 'Q' tables (BASEQ, ZTCFQ, DELTAQ).
%
%   Input:
%       BASEQ  - Table containing Base data on a uniform time grid,
%                including columns 'CHx', 'CHy', 'CHz', 'MPx', 'MPy', 'MPz'.
%       ZTCFQ  - Table containing ZTCF data on the same uniform time grid,
%                including columns 'CHx', 'CHy', 'CHz', 'MPx', 'MPy', 'MPz'.
%       DELTAQ - Table containing Delta data on the same uniform time grid,
%                including columns 'CHx', 'CHy', 'CHz', 'MPx', 'MPy', 'MPz'.
%
%   Output:
%       BASEQ  - Updated BASEQ table with added path vector columns.
%       ZTCFQ  - Updated ZTCFQ table with added path vector columns.
%       DELTAQ - Updated DELTAQ table with added path vector columns.

% --- Compute Clubhead Path Vectors (CHPx, CHPy, CHPz) ---
% Calculated as the displacement from one time step to the next.
% The original script assigned the difference (t+dt - t) to time t.
% It also copied the second-to-last difference to the last row.
% We replicate this logic using vectorized operations.

% Calculate differences using diff. This results in a vector of size N-1.
diffCHx_BASEQ = diff(BASEQ.CHx);
diffCHy_BASEQ = diff(BASEQ.CHy);
diffCHz_BASEQ = diff(BASEQ.CHz);

diffCHx_ZTCFQ = diff(ZTCFQ.CHx);
diffCHy_ZTCFQ = diff(ZTCFQ.CHy);
diffCHz_ZTCFQ = diff(ZTCFQ.CHz);

diffCHx_DELTAQ = diff(DELTAQ.CHx);
diffCHy_DELTAQ = diff(DELTAQ.CHy);
diffCHz_DELTAQ = diff(DELTAQ.CHz);

% Replicate the original script's logic: copy the last difference to the final row.
% This makes the resulting vector the same length as the original table.
BASEQ.("CHPx") = [diffCHx_BASEQ; diffCHx_BASEQ(end)];
BASEQ.("CHPy") = [diffCHy_BASEQ; diffCHy_BASEQ(end)];
BASEQ.("CHPz") = [diffCHz_BASEQ; diffCHz_BASEQ(end)];

ZTCFQ.("CHPx") = [diffCHx_ZTCFQ; diffCHx_ZTCFQ(end)];
ZTCFQ.("CHPy") = [diffCHy_ZTCFQ; diffCHy_ZTCFQ(end)];
ZTCFQ.("CHPz") = [diffCHz_ZTCFQ; diffCHz_ZTCFQ(end)];

DELTAQ.("CHPx") = [diffCHx_DELTAQ; diffCHx_DELTAQ(end)];
DELTAQ.("CHPy") = [diffCHy_DELTAQ; diffCHy_DELTAQ(end)];
DELTAQ.("CHPz") = [diffCHz_DELTAQ; diffCHz_DELTAQ(end)];


% --- Compute Midpoint Hand Path Vectors (MPPx, MPPy, MPPz) ---
% Calculated as the displacement from one time step to the next, similar to CH.

% Calculate differences using diff.
diffMPx_BASEQ = diff(BASEQ.MPx);
diffMPy_BASEQ = diff(BASEQ.MPy);
diffMPz_BASEQ = diff(BASEQ.MPz);

diffMPx_ZTCFQ = diff(ZTCFQ.MPx);
diffMPy_ZTCFQ = diff(ZTCFQ.MPy);
diffMPz_ZTCFQ = diff(ZTCFQ.MPz);

diffMPx_DELTAQ = diff(DELTAQ.MPx);
diffMPy_DELTAQ = diff(DELTAQ.MPy);
diffMPz_DELTAQ = diff(DELTAQ.MPz);

% Replicate the original script's logic: copy the last difference to the final row.
BASEQ.("MPPx") = [diffMPx_BASEQ; diffMPx_BASEQ(end)];
BASEQ.("MPPy") = [diffMPy_BASEQ; diffMPy_BASEQ(end)];
BASEQ.("MPPz") = [diffMPz_BASEQ; diffMPz_BASEQ(end)];

ZTCFQ.("MPPx") = [diffMPx_ZTCFQ; diffMPx_ZTCFQ(end)];
ZTCFQ.("MPPy") = [diffMPy_ZTCFQ; diffMPy_ZTCFQ(end)];
ZTCFQ.("MPPz") = [diffMPz_ZTCFQ; diffMPz_ZTCFQ(end)];

DELTAQ.("MPPx") = [diffMPx_DELTAQ; diffMPx_DELTAQ(end)];
DELTAQ.("MPPy") = [diffMPy_DELTAQ; diffMPy_DELTAQ(end)];
DELTAQ.("MPPz") = [diffMPz_DELTAQ; diffMPz_DELTAQ(end)];

% No need for explicit 'clear' statements within a function.
% Temporary variables like diffCHx_BASEQ are local and will be cleared automatically.

end

%%% END FILE: calculatePathVectors3D.m %%%

%%% START FILE: calculateTotalWorkAndPower3D.m %%%
function [BASEQ_updated, ZTCFQ_updated, DELTAQ_updated] = calculateTotalWorkAndPower3D(BASEQ, ZTCFQ, DELTAQ)
% CALCULATETOTALWORKANDPOWER3D Computes total and fractional work and power for segments.
%   [BASEQ_updated, ZTCFQ_updated, DELTAQ_updated] = CALCULATETOTALWORKANDPOWER3D(BASEQ, ZTCFQ, DELTAQ)
%   Calculates the total work (Linear Work + Angular Work) and total power
%   (Linear Power + Angular Power) for various body segments in the BASEQ,
%   ZTCFQ, and DELTAQ tables. It also calculates the fractional work and
%   power contributed by the ZTCF and DELTA components relative to the BASE
%   case and adds these as new columns to the BASEQ table.
%
%   This function is the converted version of SCRIPT_TotalWorkandPowerCalculation_3D.m.
%   It operates on tables expected to be on a uniform time grid (like the 'Q' tables),
%   and assumes that linear and angular work/power columns have already been added
%   (e.g., by calculateWorkAndImpulse3D).
%
%   Input:
%       BASEQ  - Table containing Base data on a uniform time grid,
%                including linear/angular work and power columns.
%       ZTCFQ  - Table containing ZTCF data on the same uniform time grid,
%                including linear/angular work and power columns.
%       DELTAQ - Table containing Delta data on the same uniform time grid,
%                including linear/angular work and power columns.
%
%   Output:
%       BASEQ_updated  - Updated BASEQ table with total and fractional work/power columns.
%       ZTCFQ_updated  - Updated ZTCFQ table with total work/power columns.
%       DELTAQ_updated - Updated DELTAQ table with total work/power columns.

% Assign input tables to internal variables for modification
BASEQ_updated = BASEQ;
ZTCFQ_updated = ZTCFQ;
DELTAQ_updated = DELTAQ;

% --- Generate Total Work and Power Vectors ---
% Sum the linear and angular components for each segment and table.
% Ensure the required linear and angular work/power columns exist before summing.

% Define the required columns for calculating total work and power
requiredWorkPowerInputCols = {
    'LSLinearWorkonArm', 'LSAngularWorkonArm', 'LSonArmLinearPower', 'LSonArmAngularPower', ...
    'RSLinearWorkonArm', 'RSAngularWorkonArm', 'RSonArmLinearPower', 'RSonArmAngularPower', ...
    'LELinearWorkonForearm', 'LEAngularWorkonForearm', 'LEonForearmLinearPower', 'LEonForearmAngularPower', ...
    'RELinearWorkonForearm', 'REAngularWorkonForearm', 'REonForearmLinearPower', 'REonForearmAngularPower', ...
    'LHLinearWorkonClub', 'LHAngularWorkonClub', 'LHonClubLinearPower', 'LHonClubAngularPower', ... % Assuming LH/RH naming
    'RHLinearWorkonClub', 'RHAngularWorkonClub', 'RHonClubLinearPower', 'RHonClubAngularPower' % Assuming LH/RH naming
};

% Helper function to check if all columns exist in a table
checkCols = @(tbl, cols) all(ismember(cols, tbl.Properties.VariableNames));

% Check if input tables have the necessary columns
if checkCols(BASEQ_updated, requiredWorkPowerInputCols) && ...
   checkCols(ZTCFQ_updated, requiredWorkPowerInputCols) && ...
   checkCols(DELTAQ_updated, requiredWorkPowerInputCols)

    % BASEQ
    BASEQ_updated.TotalLSWork = BASEQ_updated.LSLinearWorkonArm + BASEQ_updated.LSAngularWorkonArm;
    BASEQ_updated.TotalRSWork = BASEQ_updated.RSLinearWorkonArm + BASEQ_updated.RSAngularWorkonArm;
    BASEQ_updated.TotalLEWork = BASEQ_updated.LELinearWorkonForearm + BASEQ_updated.LEAngularWorkonForearm;
    BASEQ_updated.TotalREWork = BASEQ_updated.RELinearWorkonForearm + BASEQ_updated.REAngularWorkonForearm;
    BASEQ_updated.TotalLHWork = BASEQ_updated.LHLinearWorkonClub + BASEQ_updated.LHAngularWorkonClub; % Assuming LH/RH naming
    BASEQ_updated.TotalRHWork = BASEQ_updated.RHLinearWorkonClub + BASEQ_updated.RHAngularWorkonClub; % Assuming LH/RH naming

    BASEQ_updated.TotalLSPower = BASEQ_updated.LSonArmLinearPower + BASEQ_updated.LSonArmAngularPower;
    BASEQ_updated.TotalRSPower = BASEQ_updated.RSonArmLinearPower + BASEQ_updated.RSonArmAngularPower;
    BASEQ_updated.TotalLEPower = BASEQ_updated.LEonForearmLinearPower + BASEQ_updated.LEonForearmAngularPower;
    BASEQ_updated.TotalREPower = BASEQ_updated.REonForearmLinearPower + BASEQ_updated.REonForearmAngularPower;
    BASEQ_updated.TotalLHPower = BASEQ_updated.LHonClubLinearPower + BASEQ_updated.LHonClubAngularPower; % Assuming LH/RH naming
    BASEQ_updated.TotalRHPower = BASEQ_updated.RHonClubLinearPower + BASEQ_updated.RHonClubAngularPower; % Assuming LH/RH naming

    % ZTCFQ
    ZTCFQ_updated.TotalLSWork = ZTCFQ_updated.LSLinearWorkonArm + ZTCFQ_updated.LSAngularWorkonArm;
    ZTCFQ_updated.TotalRSWork = ZTCFQ_updated.RSLinearWorkonArm + ZTCFQ_updated.RSAngularWorkonArm;
    ZTCFQ_updated.TotalLEWork = ZTCFQ_updated.LELinearWorkonForearm + ZTCFQ_updated.LEAngularWorkonForearm;
    ZTCFQ_updated.TotalREWork = ZTCFQ_updated.RELinearWorkonForearm + ZTCFQ_updated.REAngularWorkonForearm;
    ZTCFQ_updated.TotalLHWork = ZTCFQ_updated.LHLinearWorkonClub + ZTCFQ_updated.LHAngularWorkonClub; % Assuming LH/RH naming
    ZTCFQ_updated.TotalRHWork = ZTCFQ_updated.RHLinearWorkonClub + ZTCFQ_updated.RHAngularWorkonClub; % Assuming LH/RH naming

    ZTCFQ_updated.TotalLSPower = ZTCFQ_updated.LSonArmLinearPower + ZTCFQ_updated.LSonArmAngularPower;
    ZTCFQ_updated.TotalRSPower = ZTCFQ_updated.RSonArmLinearPower + ZTCFQ_updated.RSonArmAngularPower;
    ZTCFQ_updated.TotalLEPower = ZTCFQ_updated.LEonForearmLinearPower + ZTCFQ_updated.LEonForearmAngularPower;
    ZTCFQ_updated.TotalREPower = ZTCFQ_updated.REonForearmLinearPower + ZTCFQ_updated.REonForearmAngularPower;
    ZTCFQ_updated.TotalLHPower = ZTCFQ_updated.LHonClubLinearPower + ZTCFQ_updated.LHonClubAngularPower; % Assuming LH/RH naming
    ZTCFQ_updated.TotalRHPower = ZTCFQ_updated.RHonClubLinearPower + ZTCFQ_updated.RHonClubAngularPower; % Assuming LH/RH naming

    % DELTAQ
    DELTAQ_updated.TotalLSWork = DELTAQ_updated.LSLinearWorkonArm + DELTAQ_updated.LSAngularWorkonArm;
    DELTAQ_updated.TotalRSWork = DELTAQ_updated.RSLinearWorkonArm + DELTAQ_updated.RSAngularWorkonArm;
    DELTAQ_updated.TotalLEWork = DELTAQ_updated.LELinearWorkonForearm + DELTAQ_updated.LEAngularWorkonForearm;
    DELTAQ_updated.TotalREWork = DELTAQ_updated.RELinearWorkonForearm + DELTAQ_updated.REAngularWorkonForearm;
    DELTAQ_updated.TotalLHWork = DELTAQ_updated.LHLinearWorkonClub + DELTAQ_updated.LHAngularWorkonClub; % Assuming LH/RH naming
    DELTAQ_updated.TotalRHWork = DELTAQ_updated.RHLinearWorkonClub + DELTAQ_updated.RHAngularWorkonClub; % Assuming LH/RH naming

    DELTAQ_updated.TotalLSPower = DELTAQ_updated.LSonArmLinearPower + DELTAQ_updated.LSonArmAngularPower;
    DELTAQ_updated.TotalRSPower = DELTAQ_updated.RSonArmLinearPower + DELTAQ_updated.RSonArmAngularPower;
    DELTAQ_updated.TotalLEPower = DELTAQ_updated.LEonForearmLinearPower + DELTAQ_updated.LEonForearmAngularPower;
    DELTAQ_updated.TotalREPower = DELTAQ_updated.REonForearmLinearPower + DELTAQ_updated.REonForearmAngularPower;
    DELTAQ_updated.TotalLHPower = DELTAQ_updated.LHonClubLinearPower + DELTAQ_updated.LHonClubAngularPower; % Assuming LH/RH naming
    DELTAQ_updated.TotalRHPower = DELTAQ_updated.RHonClubLinearPower + DELTAQ_updated.RHonClubAngularPower; % Assuming LH/RH naming

else
    warning('Required linear/angular work/power columns not found in input tables. Cannot calculate total work/power.');
    % Return updated tables as is if columns are missing
    BASEQ_updated = BASEQ;
    ZTCFQ_updated = ZTCFQ;
    DELTAQ_updated = DELTAQ;
    return; % Exit the function
end


% --- Calculate the fraction of work and power being done by the ZTCF and DELTA ---
% This calculation is added as new columns to the BASEQ table.
% Avoid division by zero or very small numbers in the denominator (BASEQ Total values).
% Replace Inf/NaN results with 0 or NaN as appropriate.

% Define the required Total columns for fractional calculations
requiredTotalCols = {
    'TotalLSWork', 'TotalLSPower', 'TotalRSWork', 'TotalRSPower', ...
    'TotalLEWork', 'TotalLEPower', 'TotalREWork', 'TotalREPower', ...
    'TotalLHWork', 'TotalLHPower', 'TotalRHWork', 'TotalRHPower' % Assuming LH/RH naming
};

% Check if input tables have the necessary total columns
if checkCols(BASEQ_updated, requiredTotalCols) && ...
   checkCols(ZTCFQ_updated, requiredTotalCols) && ...
   checkCols(DELTAQ_updated, requiredTotalCols)

    % Helper function to safely divide, handling division by zero or near-zero denominators
    safeDivide = @(numerator, denominator) numerator ./ (denominator + eps(class(denominator)) * (abs(denominator) < eps(class(denominator)))); % Use eps based on data type

    % Calculate Fraction of Work and Power Done by ZTCF
    BASEQ_updated.ZTCFQLSFractionalWork = safeDivide(ZTCFQ_updated.TotalLSWork, BASEQ_updated.TotalLSWork);
    BASEQ_updated.ZTCFQRSFractionalWork = safeDivide(ZTCFQ_updated.TotalRSWork, BASEQ_updated.TotalRSWork);
    BASEQ_updated.ZTCFQLEFractionalWork = safeDivide(ZTCFQ_updated.TotalLEWork, BASEQ_updated.TotalLEWork);
    BASEQ_updated.ZTCFQREFractionalWork = safeDivide(ZTCFQ_updated.TotalREWork, BASEQ_updated.TotalREWork);
    BASEQ_updated.ZTCFQLHFractionalWork = safeDivide(ZTCFQ_updated.TotalLHWork, BASEQ_updated.TotalLHWork); % Assuming LH/RH naming
    BASEQ_updated.ZTCFQRHFractionalWork = safeDivide(ZTCFQ_updated.TotalRHWork, BASEQ_updated.TotalRHWork); % Assuming LH/RH naming

    BASEQ_updated.ZTCFQLSFractionalPower = safeDivide(ZTCFQ_updated.TotalLSPower, BASEQ_updated.TotalLSPower);
    BASEQ_updated.ZTCFQRSFractionalPower = safeDivide(ZTCFQ_updated.TotalRSPower, BASEQ_updated.TotalRSPower);
    BASEQ_updated.ZTCFQLEFractionalPower = safeDivide(ZTCFQ_updated.TotalLEPower, BASEQ_updated.TotalLEPower);
    BASEQ_updated.ZTCFQREFractionalPower = safeDivide(ZTCFQ_updated.TotalREPower, BASEQ_updated.TotalREPower);
    BASEQ_updated.ZTCFQLHFractionalPower = safeDivide(ZTCFQ_updated.TotalLHPower, BASEQ_updated.TotalLHPower); % Assuming LH/RH naming
    BASEQ_updated.ZTCFQRHFractionalPower = safeDivide(ZTCFQ_updated.TotalRHPower, BASEQ_updated.TotalRHPower); % Assuming LH/RH naming

    % Calculate Fraction of Work and Power Done by DELTA
    BASEQ_updated.DELTAQLSFractionalWork = safeDivide(DELTAQ_updated.TotalLSWork, BASEQ_updated.TotalLSWork);
    BASEQ_updated.DELTAQRSFractionalWork = safeDivide(DELTAQ_updated.TotalRSWork, BASEQ_updated.TotalRSWork);
    BASEQ_updated.DELTAQLEFractionalWork = safeDivide(DELTAQ_updated.TotalLEWork, BASEQ_updated.TotalLEWork);
    BASEQ_updated.DELTAQREFractionalWork = safeDivide(DELTAQ_updated.TotalREWork, BASEQ_updated.TotalREWork);
    BASEQ_updated.DELTAQLHFractionalWork = safeDivide(DELTAQ_updated.TotalLHWork, BASEQ_updated.TotalLHWork); % Assuming LH/RH naming
    BASEQ_updated.DELTAQRHFractionalWork = safeDivide(DELTAQ_updated.TotalRHWork, BASEQ_updated.TotalRHWork); % Assuming LH/RH naming

    BASEQ_updated.DELTAQLSFractionalPower = safeDivide(DELTAQ_updated.TotalLSPower, BASEQ_updated.TotalLSPower);
    BASEQ_updated.DELTAQRSFractionalPower = safeDivide(DELTAQ_updated.TotalRSPower, BASEQ_updated.TotalRSPower);
    BASEQ_updated.DELTAQLEFractionalPower = safeDivide(DELTAQ_updated.TotalLEPower, BASEQ_updated.TotalLEPower);
    BASEQ_updated.DELTAQREFractionalPower = safeDivide(DELTAQ_updated.TotalREPower, BASEQ_updated.TotalREPower);
    BASEQ_updated.DELTAQLHFractionalPower = safeDivide(DELTAQ_updated.TotalLHPower, BASEQ_updated.TotalLHPower); % Assuming LH/RH naming
    BASEQ_updated.DELTAQRHFractionalPower = safeDivide(DELTAQ_updated.TotalRHPower, BASEQ_updated.TotalRHPower); % Assuming LH/RH naming

else
    warning('Required total work/power columns not found for fractional calculations. Skipping fractional calculations.');
    % Initialize fractional columns to NaN if needed for consistency
    fractionalWorkFields = {'ZTCFQLSFractionalWork', 'ZTCFQRSFractionalWork', 'ZTCFQLEFractionalWork', 'ZTCFQREFractionalWork', 'ZTCFQLHFractionalWork', 'ZTCFQRHFractionalWork', ...
                            'DELTAQLSFractionalWork', 'DELTAQRSFractionalWork', 'DELTAQLEFractionalWork', 'DELTAQREFractionalWork', 'DELTAQLHFractionalWork', 'DELTAQRHFractionalWork'};
    fractionalPowerFields = {'ZTCFQLSFractionalPower', 'ZTCFQRSFractionalPower', 'ZTCFQLEFractionalPower', 'ZTCFQREFractionalPower', 'ZTCFQLHFractionalPower', 'ZTCFQRHFractionalPower', ...
                             'DELTAQLSFractionalPower', 'DELTAQRSFractionalPower', 'DELTAQLEFractionalPower', 'DELTAQREFractionalPower', 'DELTAQLHFractionalPower', 'DELTAQRHFractionalPower'};

     for k = 1:length(fractionalWorkFields)
         BASEQ_updated.(fractionalWorkFields{k}) = NaN(height(BASEQ_updated), 1);
     end
      for k = 1:length(fractionalPowerFields)
         BASEQ_updated.(fractionalPowerFields{k}) = NaN(height(BASEQ_updated), 1);
     end
end


% No need for explicit 'clear' statements within a function.
% All intermediate variables are local and cleared automatically.

end

%%% END FILE: calculateTotalWorkAndPower3D.m %%%

%%% START FILE: calculateWorkAndImpulse3D.m %%%
function [ZTCFQ_updated, DELTAQ_updated] = calculateWorkAndImpulse3D(ZTCFQ, DELTAQ)
% CALCULATEWORKANDIMPULSE3D Numerically computes work and impulse for segments.
%   [ZTCFQ_updated, DELTAQ_updated] = CALCULATEWORKANDIMPULSE3D(ZTCFQ, DELTAQ)
%   Calculates linear work (integral of Power = F.V), linear impulse (integral of F),
%   angular work (integral of Angular Power = T.AV), and angular impulse
%   (integral of Sum of Moments) for various body segments based on the
%   data in the ZTCFQ and DELTAQ tables. New columns for these calculated
%   values are added to the output tables.
%
%   This function is the converted version of SCRIPT_UpdateCalcsforImpulseandWork_3D.m.
%   It operates on tables expected to be on a uniform time grid (like the 'Q' tables).
%
%   Input:
%       ZTCFQ  - Table containing ZTCF data on a uniform time grid,
%                including columns for forces, torques, velocities,
%                angular velocities, and sum of moments.
%       DELTAQ - Table containing Delta data on the same uniform time grid,
%                including columns for forces, torques, velocities,
%                angular velocities, and sum of moments.
%
%   Output:
%       ZTCFQ_updated  - Updated ZTCFQ table with added work and impulse columns.
%       DELTAQ_updated - Updated DELTAQ table with added work and impulse columns.

% Assign input tables to internal variables for modification
ZTCFQ_updated = ZTCFQ;
DELTAQ_updated = DELTAQ;

% --- Get Time Step (Assuming Uniform Grid) ---
% Calculate the time step from the input table's time vector.
% Since the tables are on a uniform TsQ grid, the difference between
% any two consecutive time points should be the time step.
if height(ZTCFQ_updated) > 1
    TsQ = ZTCFQ_updated.Time(2) - ZTCFQ_updated.Time(1);
else
    % Handle case with 0 or 1 data point (cannot calculate impulse/work)
    warning('Input table has less than 2 rows. Cannot calculate work/impulse.');
    % Return the original tables without adding columns
    return;
end

% --- Process ZTCFQ Table ---

fprintf('Calculating work and impulse for ZTCFQ...\n');

% Extract necessary data columns from ZTCFQ
% Ensure these column names match your logged signals from the 3D model
try
    % Forces (Global frame, expected as Nx3)
    F_ZTCF = ZTCFQ_updated{:, ["TotalHandForceGlobalX", "TotalHandForceGlobalY", "TotalHandForceGlobalZ"]};
    LHF_ZTCF = ZTCFQ_updated{:, ["LHonClubFGlobalX", "LHonClubFGlobalY", "LHonClubFGlobalZ"]};
    RHF_ZTCF = ZTCFQ_updated{:, ["RHonClubFGlobalX", "RHonClubFGlobalY", "RHonClubFGlobalZ"]};
    LEF_ZTCF = ZTCFQ_updated{:, ["LArmonLForearmFGlobalX", "LArmonLForearmFGlobalY", "LArmonLForearmFGlobalZ"]};
    REF_ZTCF = ZTCFQ_updated{:, ["RArmonRForearmFGlobalX", "RArmonRForearmFGlobalY", "RArmonRForearmFGlobalZ"]};
    LSF_ZTCF = ZTCFQ_updated{:, ["LSonLArmFGlobalX", "LSonLArmFGlobalY", "LSonLArmFGlobalZ"]};
    RSF_ZTCF = ZTCFQ_updated{:, ["RSonRArmFGlobalX", "RSonRArmFGlobalY", "RSonRArmFGlobalZ"]};

    % Sum of Moments (Global frame, expected as Nx3) - Used for Angular Impulse
    SUMLS_ZTCF = ZTCFQ_updated{:, ["SumofMomentsLSonLArmX", "SumofMomentsLSonLArmY", "SumofMomentsLSonLArmZ"]};
    SUMRS_ZTCF = ZTCFQ_updated{:, ["SumofMomentsRSonRArmX", "SumofMomentsRSonRArmY", "SumofMomentsRSonRArmZ"]};
    SUMLE_ZTCF = ZTCFQ_updated{:, ["SumofMomentsLEonLForearmX", "SumofMomentsLEonLForearmY", "SumofMomentsLEonLForearmZ"]};
    SUMRE_ZTCF = ZTCFQ_updated{:, ["SumofMomentsREonRForearmX", "SumofMomentsREonRForearmY", "SumofMomentsREonRForearmZ"]};
    % Assuming LH/RH naming for wrist moments
    SUMLH_ZTCF = ZTCFQ_updated{:, ["SumofMomentsLHonClubX", "SumofMomentsLHonClubY", "SumofMomentsLHonClubZ"]};
    SUMRH_ZTCF = ZTCFQ_updated{:, ["SumofMomentsRHonClubX", "SumofMomentsRHonClubY", "SumofMomentsRHonClubZ"]};

    % Torques (Global frame, expected as Nx3) - Used for Angular Work
    TLS_ZTCF = ZTCFQ_updated{:, ["LSonLArmTGlobalX", "LSonLArmTGlobalY", "LSonLArmTGlobalZ"]};
    TRS_ZTCF = ZTCFQ_updated{:, ["RSonRArmTGlobalX", "RSonRArmTGlobalY", "RSonRArmTGlobalZ"]};
    TLE_ZTCF = ZTCFQ_updated{:, ["LArmonLForearmTGlobalX", "LArmonLForearmTGlobalY", "LArmonLForearmTGlobalZ"]};
    TRE_ZTCF = ZTCFQ_updated{:, ["RArmonRForearmTGlobalX", "RArmonRForearmTGlobalY", "RArmonRForearmTGlobalZ"]};
    % Assuming LH/RH naming for wrist torques
    TLH_ZTCF = ZTCFQ_updated{:, ["LHonClubTGlobalX", "LHonClubTGlobalY", "LHonClubTGlobalZ"]};
    TRH_ZTCF = ZTCFQ_updated{:, ["RHonClubTGlobalX", "RHonClubTGlobalY", "RHonClubTGlobalZ"]};

    % Velocities (Global frame, expected as Nx3)
    V_ZTCF = ZTCFQ_updated{:, ["MidHandVelocityX", "MidHandVelocityY", "MidHandVelocityZ"]};
    LHV_ZTCF = ZTCFQ_updated{:, ["LeftHandVelocityX", "LeftHandVelocityY", "LeftHandVelocityZ"]};
    RHV_ZTCF = ZTCFQ_updated{:, ["RightHandVelocityX", "RightHandVelocityY", "RightHandVelocityZ"]};
    LEV_ZTCF = ZTCFQ_updated{:, ["LEvGlobalX", "LEvGlobalY", "LEvGlobalZ"]};
    REV_ZTCF = ZTCFQ_updated{:, ["REvGlobalX", "REvGlobalY", "REvGlobalZ"]};
    LSV_ZTCF = ZTCFQ_updated{:, ["LSvGlobalX", "LSvGlobalY", "LSvGlobalZ"]};
    RSV_ZTCF = ZTCFQ_updated{:, ["RSvGlobalX", "RSvGlobalY", "RSvGlobalZ"]};

    % Angular Velocities (Global frame, expected as Nx3)
    LSAV_ZTCF = ZTCFQ_updated{:, ["LSAVGlobalX", "LSAVGlobalY", "LSAVGlobalZ"]};
    RSAV_ZTCF = ZTCFQ_updated{:, ["RSAVGlobalX", "RSAVGlobalY", "RSAVGlobalZ"]};
    LEAV_ZTCF = ZTCFQ_updated{:, ["LEAVGlobalX", "LEAVGlobalY", "LEAVGlobalZ"]};
    REAV_ZTCF = ZTCFQ_updated{:, ["REAVGlobalX", "REAVGlobalY", "REAVGlobalZ"]};
    LHAV_ZTCF = ZTCFQ_updated{:, ["LeftWristGlobalAVX", "LeftWristGlobalAVY", "LeftWristGlobalAVZ"]};
    RHAV_ZTCF = ZTCFQ_updated{:, ["RightWristGlobalAVX", "RightWristGlobalAVY", "RightWristGlobalAVZ"]};

catch ME
    warning('Error extracting required columns for ZTCFQ calculations: %s', ME.message);
    % Return the original tables as is if columns are missing
    ZTCFQ_updated = ZTCFQ;
    DELTAQ_updated = DELTAQ;
    return; % Exit the function
end


% Calculate Linear Power (Dot product of Force and Linear Velocity)
P_ZTCF = sum(F_ZTCF .* V_ZTCF, 2); % Element-wise product then sum across columns
LHP_ZTCF = sum(LHF_ZTCF .* LHV_ZTCF, 2);
RHP_ZTCF = sum(RHF_ZTCF .* RHV_ZTCF, 2);
LEP_ZTCF = sum(LEF_ZTCF .* LEV_ZTCF, 2);
REP_ZTCF = sum(REF_ZTCF .* REV_ZTCF, 2);
LSP_ZTCF = sum(LSF_ZTCF .* LSV_ZTCF, 2);
RSP_ZTCF = sum(RSF_ZTCF .* RSV_ZTCF, 2);

% Calculate Angular Power (Dot product of Torque and Angular Velocity)
LSAP_ZTCF = sum(TLS_ZTCF .* LSAV_ZTCF, 2);
RSAP_ZTCF = sum(TRS_ZTCF .* RSAV_ZTCF, 2);
LEAP_ZTCF = sum(TLE_ZTCF .* LEAV_ZTCF, 2);
REAP_ZTCF = sum(TRE_ZTCF .* REAV_ZTCF, 2);
LHAP_ZTCF = sum(TLH_ZTCF .* LHAV_ZTCF, 2);
RHAP_ZTCF = sum(TRH_ZTCF .* RHAV_ZTCF, 2);


% Numerically Integrate to find Work and Impulse (using cumtrapz)
% cumtrapz(X, Y) integrates Y with respect to X. Using Time is more robust.
timeVec = ZTCFQ_updated.Time;

% Linear Work (Integral of Linear Power)
ZTCFQ_updated.("LinearWorkonClub") = cumtrapz(timeVec, P_ZTCF);
ZTCFQ_updated.("LHLinearWorkonClub") = cumtrapz(timeVec, LHP_ZTCF);
ZTCFQ_updated.("RHLinearWorkonClub") = cumtrapz(timeVec, RHP_ZTCF);
ZTCFQ_updated.("LELinearWorkonForearm") = cumtrapz(timeVec, LEP_ZTCF);
ZTCFQ_updated.("RELinearWorkonForearm") = cumtrapz(timeVec, REP_ZTCF);
ZTCFQ_updated.("LSLinearWorkonArm") = cumtrapz(timeVec, LSP_ZTCF);
ZTCFQ_updated.("RSLinearWorkonArm") = cumtrapz(timeVec, RSP_ZTCF);

% Linear Impulse (Integral of Force) - Note: cumtrapz on Nx3 matrix integrates each column
ZTCFQ_updated.("LinearImpulseonClub") = cumtrapz(timeVec, F_ZTCF);
ZTCFQ_updated.("LHLinearImpulseonClub") = cumtrapz(timeVec, LHF_ZTCF);
ZTCFQ_updated.("RHLinearImpulseonClub") = cumtrapz(timeVec, RHF_ZTCF);
ZTCFQ_updated.("LELinearImpulseonForearm") = cumtrapz(timeVec, LEF_ZTCF);
ZTCFQ_updated.("RELinearImpulseonForearm") = cumtrapz(timeVec, REF_ZTCF);
ZTCFQ_updated.("LSLinearImpulseonArm") = cumtrapz(timeVec, LSF_ZTCF);
ZTCFQ_updated.("RSLinearImpulseonArm") = cumtrapz(timeVec, RSF_ZTCF);

% Angular Impulse (Integral of Sum of Moments)
ZTCFQ_updated.("LSAngularImpulseonArm") = cumtrapz(timeVec, SUMLS_ZTCF);
ZTCFQ_updated.("RSAngularImpulseonArm") = cumtrapz(timeVec, SUMRS_ZTCF);
ZTCFQ_updated.("LEAngularImpulseonForearm") = cumtrapz(timeVec, SUMLE_ZTCF);
ZTCFQ_updated.("REAngularImpulseonForearm") = cumtrapz(timeVec, SUMRE_ZTCF);
ZTCFQ_updated.("LHAngularImpulseonClub") = cumtrapz(timeVec, SUMLH_ZTCF);
ZTCFQ_updated.("RHAngularImpulseonClub") = cumtrapz(timeVec, SUMRH_ZTCF);

% Angular Work (Integral of Angular Power)
ZTCFQ_updated.("LSAngularWorkonArm") = cumtrapz(timeVec, LSAP_ZTCF);
ZTCFQ_updated.("RSAngularWorkonArm") = cumtrapz(timeVec, RSAP_ZTCF);
ZTCFQ_updated.("LEAngularWorkonForearm") = cumtrapz(timeVec, LEAP_ZTCF);
ZTCFQ_updated.("REAngularWorkonForearm") = cumtrapz(timeVec, REAP_ZTCF);
ZTCFQ_updated.("LHAngularWorkonClub") = cumtrapz(timeVec, LHAP_ZTCF);
ZTCFQ_updated.("RHAngularWorkonClub") = cumtrapz(timeVec, RHAP_ZTCF);

fprintf('ZTCFQ work and impulse calculations complete.\n');

% --- Process DELTAQ Table ---

fprintf('Calculating work and impulse for DELTAQ...\n');

% Extract necessary data columns from DELTAQ
% Ensure these column names match your logged signals
try
    % Forces (Global frame, expected as Nx3)
    F_DELTA = DELTAQ_updated{:, ["TotalHandForceGlobalX", "TotalHandForceGlobalY", "TotalHandForceGlobalZ"]};
    LHF_DELTA = DELTAQ_updated{:, ["LHonClubFGlobalX", "LHonClubFGlobalY", "LHonClubFGlobalZ"]};
    RHF_DELTA = DELTAQ_updated{:, ["RHonClubFGlobalX", "RHonClubFGlobalY", "RHonClubFGlobalZ"]};
    LEF_DELTA = DELTAQ_updated{:, ["LArmonLForearmFGlobalX", "LArmonLForearmFGlobalY", "LArmonLForearmFGlobalZ"]};
    REF_DELTA = DELTAQ_updated{:, ["RArmonRForearmFGlobalX", "RArmonRForearmFGlobalY", "RArmonRForearmFGlobalZ"]};
    LSF_DELTA = DELTAQ_updated{:, ["LSonLArmFGlobalX", "LSonLArmFGlobalY", "LSonLArmFGlobalZ"]};
    RSF_DELTA = DELTAQ_updated{:, ["RSonRArmFGlobalX", "RSonRArmFGlobalY", "RSonRArmFGlobalZ"]};

    % Sum of Moments (Global frame, expected as Nx3) - Used for Angular Impulse
    SUMLS_DELTA = DELTAQ_updated{:, ["SumofMomentsLSonLArmX", "SumofMomentsLSonLArmY", "SumofMomentsLSonLArmZ"]};
    SUMRS_DELTA = DELTAQ_updated{:, ["SumofMomentsRSonRArmX", "SumofMomentsRSonRArmY", "SumofMomentsRSonRArmZ"]};
    SUMLE_DELTA = DELTAQ_updated{:, ["SumofMomentsLEonLForearmX", "SumofMomentsLEonLForearmY", "SumofMomentsLEonLForearmZ"]};
    SUMRE_DELTA = DELTAQ_updated{:, ["SumofMomentsREonRForearmX", "SumofMomentsREonRForearmY", "SumofMomentsREonRForearmZ"]};
    SUMLH_DELTA = DELTAQ_updated{:, ["SumofMomentsLHonClubX", "SumofMomentsLHonClubY", "SumofMomentsLHonClubZ"]};
    SUMRH_DELTA = DELTAQ_updated{:, ["SumofMomentsRHonClubX", "SumofMomentsRHonClubY", "SumofMomentsRHonClubZ"]};

    % Torques (Global frame, expected as Nx3) - Used for Angular Work
    TLS_DELTA = DELTAQ_updated{:, ["LSonLArmTGlobalX", "LSonLArmTGlobalY", "LSonLArmTGlobalZ"]};
    TRS_DELTA = DELTAQ_updated{:, ["RSonRArmTGlobalX", "RSonRArmTGlobalY", "RSonRArmTGlobalZ"]};
    TLE_DELTA = DELTAQ_updated{:, ["LArmonLForearmTGlobalX", "LArmonLForearmTGlobalY", "LArmonLForearmTGlobalZ"]};
    TRE_DELTA = DELTAQ_updated{:, ["RArmonRForearmTGlobalX", "RArmonRForearmTGlobalY", "RArmonRForearmTGlobalZ"]};
    TLH_DELTA = DELTAQ_updated{:, ["LHonClubTGlobalX", "LHonClubTGlobalY", "LHonClubTGlobalZ"]};
    TRH_DELTA = DELTAQ_updated{:, ["RHonClubTGlobalX", "RHonClubTGlobalY", "RHonClubTGlobalZ"]};

    % Velocities (Global frame, expected as Nx3) - NOTE: Using ZTCFQ velocities as in original script
    % This is a potential point of confusion/review. If DELTA represents the *difference*
    % in forces/torques, should it be multiplied by BASE velocities or DELTA velocities?
    % Sticking to original script's logic using ZTCFQ velocities for now.
    V_DELTA = ZTCFQ{:, ["MidHandVelocityX", "MidHandVelocityY", "MidHandVelocityZ"]};
    LHV_DELTA = ZTCFQ{:, ["LeftHandVelocityX", "LeftHandVelocityY", "LeftHandVelocityZ"]};
    RHV_DELTA = ZTCFQ{:, ["RightHandVelocityX", "RightHandVelocityY", "RightHandVelocityZ"]};
    LEV_DELTA = ZTCFQ{:, ["LEvGlobalX", "LEvGlobalY", "LEvGlobalZ"]};
    REV_DELTA = ZTCFQ{:, ["REvGlobalX", "REvGlobalY", "REvGlobalZ"]};
    LSV_DELTA = ZTCFQ{:, ["LSvGlobalX", "LSvGlobalY", "LSvGlobalZ"]};
    RSV_DELTA = ZTCFQ{:, ["RSvGlobalX", "RSvGlobalY", "RSvGlobalZ"]};

    % Angular Velocities (Global frame, expected as Nx3) - NOTE: Using ZTCFQ angular velocities as in original script
    LSAV_DELTA = ZTCFQ{:, ["LSAVGlobalX", "LSAVGlobalY", "LSAVGlobalZ"]};
    RSAV_DELTA = ZTCFQ{:, ["RSAVGlobalX", "RSAVGlobalY", "RSAVGlobalZ"]};
    LEAV_DELTA = ZTCFQ{:, ["LEAVGlobalX", "LEAVGlobalY", "LEAVGlobalZ"]};
    REAV_DELTA = ZTCFQ{:, ["REAVGlobalX", "REAVGlobalY", "REAVGlobalZ"]};
    LHAV_DELTA = ZTCFQ{:, ["LeftWristGlobalAVX", "LeftWristGlobalAVY", "LeftWristGlobalAVZ"]};
    RHAV_DELTA = ZTCFQ{:, ["RightWristGlobalAVX", "RightWristGlobalAVY", "RightWristGlobalAVZ"]};

catch ME
    warning('Error extracting required columns for DELTAQ calculations: %s', ME.message);
    % Return the original tables as is if columns are missing
    ZTCFQ_updated = ZTCFQ;
    DELTAQ_updated = DELTAQ;
    return; % Exit the function
end

% Calculate Linear Power (Dot product of Force and Linear Velocity)
P_DELTA = sum(F_DELTA .* V_DELTA, 2); % Element-wise product then sum across columns
LHP_DELTA = sum(LHF_DELTA .* LHV_DELTA, 2);
RHP_DELTA = sum(RHF_DELTA .* RHV_DELTA, 2);
LEP_DELTA = sum(LEF_DELTA .* LEV_DELTA, 2);
REP_DELTA = sum(REF_DELTA .* REV_DELTA, 2);
LSP_DELTA = sum(LSF_DELTA .* LSV_DELTA, 2);
RSP_DELTA = sum(RSF_DELTA .* RSV_DELTA, 2);

% Calculate Angular Power (Dot product of Torque and Angular Velocity)
LSAP_DELTA = sum(TLS_DELTA .* LSAV_DELTA, 2);
RSAP_DELTA = sum(TRS_DELTA .* RSAV_DELTA, 2);
LEAP_DELTA = sum(TLE_DELTA .* LEAV_DELTA, 2);
REAP_DELTA = sum(TRE_DELTA .* REAV_DELTA, 2);
LHAP_DELTA = sum(TLH_DELTA .* LHAV_DELTA, 2);
RHAP_DELTA = sum(TRH_DELTA .* RHAV_DELTA, 2);


% Numerically Integrate to find Work and Impulse (using cumtrapz)
% Use the time vector from DELTAQ (should be the same as ZTCFQ)
timeVec = DELTAQ_updated.Time;

% Linear Work (Integral of Linear Power)
DELTAQ_updated.("LinearWorkonClub") = cumtrapz(timeVec, P_DELTA);
DELTAQ_updated.("LHLinearWorkonClub") = cumtrapz(timeVec, LHP_DELTA);
DELTAQ_updated.("RHLinearWorkonClub") = cumtrapz(timeVec, RHP_DELTA);
DELTAQ_updated.("LELinearWorkonForearm") = cumtrapz(timeVec, LEP_DELTA);
DELTAQ_updated.("RELinearWorkonForearm") = cumtrapz(timeVec, REP_DELTA);
DELTAQ_updated.("LSLinearWorkonArm") = cumtrapz(timeVec, LSP_DELTA);
DELTAQ_updated.("RSLinearWorkonArm") = cumtrapz(timeVec, RSP_DELTA);

% Linear Impulse (Integral of Force)
DELTAQ_updated.("LinearImpulseonClub") = cumtrapz(timeVec, F_DELTA);
DELTAQ_updated.("LHLinearImpulseonClub") = cumtrapz(timeVec, LHF_DELTA);
DELTAQ_updated.("RHLinearImpulseonClub") = cumtrapz(timeVec, RHF_DELTA);
DELTAQ_updated.("LELinearImpulseonForearm") = cumtrapz(timeVec, LEF_DELTA);
DELTAQ_updated.("RELinearImpulseonForearm") = cumtrapz(timeVec, REF_DELTA);
DELTAQ_updated.("LSLinearImpulseonArm") = cumtrapz(timeVec, LSF_DELTA);
DELTAQ_updated.("RSLinearImpulseonArm") = cumtrapz(timeVec, RSF_DELTA);

% Angular Impulse (Integral of Sum of Moments)
DELTAQ_updated.("LSAngularImpulseonArm") = cumtrapz(timeVec, SUMLS_DELTA);
DELTAQ_updated.("RSAngularImpulseonArm") = cumtrapz(timeVec, SUMRS_DELTA);
DELTAQ_updated.("LEAngularImpulseonForearm") = cumtrapz(timeVec, SUMLE_DELTA);
DELTAQ_updated.("REAngularImpulseonForearm") = cumtrapz(timeVec, SUMRE_DELTA);
DELTAQ_updated.("LHAngularImpulseonClub") = cumtrapz(timeVec, SUMLH_DELTA);
DELTAQ_updated.("RHAngularImpulseonClub") = cumtrapz(timeVec, SUMRH_DELTA);

% Angular Work (Integral of Angular Power)
DELTAQ_updated.("LSAngularWorkonArm") = cumtrapz(timeVec, LSAP_DELTA);
DELTAQ_updated.("RSAngularWorkonArm") = cumtrapz(timeVec, RSAP_DELTA);
DELTAQ_updated.("LEAngularWorkonForearm") = cumtrapz(timeVec, LEAP_DELTA);
DELTAQ_updated.("REAngularWorkonForearm") = cumtrapz(timeVec, REAP_DELTA);
DELTAQ_updated.("LHAngularWorkonClub") = cumtrapz(timeVec, LHAP_DELTA);
DELTAQ_updated.("RHAngularWorkonClub") = cumtrapz(timeVec, RHAP_DELTA);

fprintf('DELTAQ work and impulse calculations complete.\n');

% No need for explicit 'clear' statements within a function.
% All intermediate variables are local and cleared automatically.

end

%%% END FILE: calculateWorkAndImpulse3D.m %%%

%%% START FILE: combine_plot_scripts.m %%%
function combine_plot_scripts()
% COMBINE_PLOT_SCRIPTS - Consolidates multiple plot() scripts into one master file.
% Prompts user to select scripts from a folder, determines prefix from folder name,
% and replaces detected variables unless they already belong to known prefixes.

% Define known prefixes to preserve
knownPrefixes = {'BASEQ', 'DELTAQ', 'ZTCFQ', 'ZVCFQ', 'ModelData', 'DataTable'};

[fileNames, pathName] = uigetfile('*.m', 'Select PLOT scripts to combine', 'MultiSelect', 'on');
if isequal(fileNames, 0)
    disp('No files selected.');
    return;
end
if ischar(fileNames)
    fileNames = {fileNames};
end

[~, folderName] = fileparts(pathName);
caseName = upper(regexprep(folderName, '[^a-zA-Z0-9]', ''));
varPrefix = caseName;  % Assume variable name matches case name
outputFileName = fullfile(pathName, ['PLOT_' caseName '_Plots.m']);

header = sprintf([...
    'function PLOT_%s_Plots(%s)\n',...
    '%%% Auto-generated combined script\n',...
    '%%% Generated from %d files on %s\n\n'], ...
    caseName, varPrefix, numel(fileNames), datestr(now));

fidOut = fopen(outputFileName, 'w');
fprintf(fidOut, '%s', header);

for i = 1:length(fileNames)
    filePath = fullfile(pathName, fileNames{i});
    fprintf('\nProcessing %s...\n', fileNames{i});

    fprintf(fidOut, '%%%% ====== Start of %s ======\n', fileNames{i});

    lines = readlines(filePath);
    lines = strtrim(lines);
    lines = lines(~cellfun('isempty', lines));

    for j = 1:numel(lines)
        line = lines(j);

        if contains(line, 'clear') || contains(line, 'close all') || contains(line, 'clearvars')
            continue;
        end

        alreadyPrefixed = false;
        for k = 1:numel(knownPrefixes)
            if contains(line, [knownPrefixes{k}, '.'])
                alreadyPrefixed = true;
                break;
            end
        end

        if ~alreadyPrefixed
            line = regexprep(line, '\b([A-Z][A-Za-z0-9_]+)\(', [varPrefix, '.$1(']);
            line = regexprep(line, '\b([A-Z][A-Za-z0-9_]+)\.', [varPrefix, '.$1.']);
        end

        fprintf(fidOut, '%s\n', line);
    end

    fprintf(fidOut, '\n%%%% ====== End of %s ======\n\n', fileNames{i});
end

fprintf(fidOut, 'end\n');
fclose(fidOut);
disp(['Combined script saved to: ', outputFileName]);
end

%%% END FILE: combine_plot_scripts.m %%%

%%% START FILE: generateDataTable3D.m %%%
function Data = generateDataTable3D(simOutput)
% GENERATEDATATABLE3D Extracts data from 3D Simulink simulation output into a table.
%   Data = GENERATEDATATABLE3D(simOutput) processes the Simulink
%   simulation output object 'simOutput' from the 3D golf swing model
%   and extracts the time vector and logged signals into a MATLAB table.
%   It also calculates and adds 3D segment direction vectors (Grip, Shaft,
%   Forearm, Upper Arm, Shoulder) to the table for visualization or analysis.
%
%   Input:
%       simOutput - A Simulink simulation output object logged as a single
%                   object, expected to contain 'tout' (time) and 'logsout'
%                   (logged signals). 'logsout' should be a Dataset object.
%
%   Output:
%       Data - A MATLAB table containing simulation time and all logged
%              signals from 'simOutput.logsout', plus calculated 3D segment vectors.

% --- Extract Time and Logged Signals ---

% Generate a table with a time column from the simulation output time vector.
Time = simOutput.tout;
Data = table(Time, 'VariableNames', {'Time'});

% Loop through each dataset element in logsout to add it to the table.
% This method is robust to changes in the number or order of logged signals
% in the Simulink model, as long as the signal names are valid table variable names.
if isfield(simOutput, 'logsout') && ~isempty(simOutput.logsout)
    for i = 1:simOutput.logsout.numElements
        % Get signal element from the logsout Dataset
        signalElement = simOutput.logsout.getElement(i);

        % Get signal name and data
        signalName = signalElement.Name;
        signalData = signalElement.Values.Data;

        % Add the data as a new column in the table, using the signal name.
        % The .(signalName) syntax allows using the string signalName as a field/variable name.
        % Ensure signalName is a valid MATLAB table variable name if necessary,
        % though logsout names are usually compatible.
        Data.(signalName) = signalData;
    end
else
    warning('Simulink output object does not contain logsout data.');
    % The table will contain only the time vector in this case.
end


% --- Generate 3D Segment Vector Components ---
% These vectors are calculated for visualization (e.g., quiver plots) or
% further analysis based on the positions of key points logged from the model.

% Grip Scale Factor (Optional: Scale up grip vector for graphics if needed)
% Adjust this value based on desired visualization size relative to other vectors.
GripScale = 1.5;

% Generate Grip Vector in Table (e.g., from Butt to RW, scaled)
% Assumes 'RWx', 'RWy', 'RWz', 'Buttx', 'Butty', 'Buttz' are logged signals.
if all(ismember({'RWx', 'RWy', 'RWz', 'Buttx', 'Butty', 'Buttz'}, Data.Properties.VariableNames))
    Data.Gripdx = GripScale .* (Data.RWx - Data.Buttx);
    Data.Gripdy = GripScale .* (Data.RWy - Data.Butty);
    Data.Gripdz = GripScale .* (Data.RWz - Data.Buttz);
end
% GripScale variable is local to this function, no need to clear explicitly.

% Generate Shaft Vector in Table (e.g., from RW to CH)
% Assumes 'CHx', 'CHy', 'CHz', 'RWx', 'RWy', 'RWz' are logged signals.
if all(ismember({'CHx', 'CHy', 'CHz', 'RWx', 'RWy', 'RWz'}, Data.Properties.VariableNames))
    Data.Shaftdx = Data.CHx - Data.RWx;
    Data.Shaftdy = Data.CHy - Data.RWy;
    Data.Shaftdz = Data.CHz - Data.RWz;
end

% Generate Left Forearm Vector in Table (e.g., from LE to LW)
% Assumes 'LWx', 'LWy', 'LWz', 'LEx', 'LEy', 'LEz' are logged signals.
if all(ismember({'LWx', 'LWy', 'LWz', 'LEx', 'LEy', 'LEz'}, Data.Properties.VariableNames))
    Data.LeftForearmdx = Data.LWx - Data.LEx;
    Data.LeftForearmdy = Data.LWy - Data.LEy;
    Data.LeftForearmdz = Data.LWz - Data.LEz;
end

% Generate Right Forearm Vector in Table (e.g., from RE to RW)
% Assumes 'RWx', 'RWy', 'RWz', 'REx', 'REy', 'REz' are logged signals.
if all(ismember({'RWx', 'RWy', 'RWz', 'REx', 'REy', 'REz'}, Data.Properties.VariableNames))
    Data.RightForearmdx = Data.RWx - Data.REx;
    Data.RightForearmdy = Data.RWy - Data.REy;
    Data.RightForearmdz = Data.RWz - Data.REz;
end

% Generate Left Upper Arm Vector in Table (e.g., from LS to LE)
% Assumes 'LEx', 'LEy', 'LEz', 'LSx', 'LSy', 'LSz' are logged signals.
if all(ismember({'LEx', 'LEy', 'LEz', 'LSx', 'LSy', 'LSz'}, Data.Properties.VariableNames))
    Data.LeftArmdx = Data.LEx - Data.LSx;
    Data.LeftArmdy = Data.LEy - Data.LSy;
    Data.LeftArmdz = Data.LEz - Data.LSz;
end

% Generate Right Upper Arm Vector in Table (e.g., from RS to RE)
% Assumes 'REx', 'REy', 'REz', 'RSx', 'RSy', 'RSz' are logged signals.
if all(ismember({'REx', 'REy', 'REz', 'RSx', 'RSy', 'RSz'}, Data.Properties.VariableNames))
    Data.RightArmdx = Data.REx - Data.RSx;
    Data.RightArmdy = Data.REy - Data.RSy;
    Data.RightArmdz = Data.REz - Data.RSz;
end

% Generate Left Shoulder Vector (e.g., from HUB to LS)
% Assumes 'LSx', 'LSy', 'LSz', 'HUBx', 'HUBy', 'HUBz' are logged signals.
if all(ismember({'LSx', 'LSy', 'LSz', 'HUBx', 'HUBy', 'HUBz'}, Data.Properties.VariableNames))
    Data.LeftShoulderdx = Data.LSx - Data.HUBx;
    Data.LeftShoulderdy = Data.LSy - Data.HUBy;
    Data.LeftShoulderdz = Data.LSz - Data.HUBz;
end

% Generate Right Shoulder Vector (e.g., from HUB to RS)
% Assumes 'RSx', 'RSy', 'RSz', 'HUBx', 'HUBy', 'HUBz' are logged signals.
if all(ismember({'RSx', 'RSy', 'RSz', 'HUBx', 'HUBy', 'HUBz'}, Data.Properties.VariableNames))
    Data.RightShoulderdx = Data.RSx - Data.HUBx;
    Data.RightShoulderdy = Data.RSy - Data.HUBy;
    Data.RightShoulderdz = Data.RSz - Data.HUBz;
end

% Variables created inside this function (Time, i, signalElement, signalName,
% signalData, GripScale, etc.) are local and automatically cleared when
% the function finishes execution. Explicit 'clear' statements are not needed.

end

%%% END FILE: generateDataTable3D.m %%%

%%% START FILE: generateResultsFolder3D.m %%%
function generateResultsFolder3D(projectRoot, caseID)
% GENERATERESULTSFOLDER3D Creates a results folder structure and copies output files.
%   GENERATERESULTSFOLDER3D(projectRoot, caseID) creates a 'Model Output/<caseID>' folder
%   structure within the specified projectRoot and copies various files
%   (scripts, models, parameters, charts, tables) into the corresponding
%   subfolders and archives all scripts into a text file.

if nargin < 2
    caseID = 'Run_Unknown';
end

warning('off', 'MATLAB:MKDIR:DirectoryExists');

% Define the main results folder path
resultsFolder = fullfile(projectRoot, 'Model Output', caseID);

% Create output folders
scriptsFolder = fullfile(resultsFolder, 'Scripts');
modelsFolder = fullfile(resultsFolder, 'Model and Parameters');
chartsFolder = fullfile(resultsFolder, 'Charts');
tablesFolder = fullfile(resultsFolder, 'Tables');
archiveFolder = fullfile(resultsFolder, 'ScriptArchives');

mkdir(resultsFolder);
mkdir(scriptsFolder);
mkdir(modelsFolder);
mkdir(chartsFolder);
mkdir(tablesFolder);
mkdir(archiveFolder);

fprintf('Creating results folder structure at: %s\n', resultsFolder);

% Define source and destination base paths
sourceScriptsBase = fullfile(projectRoot, 'Scripts');
sourceTablesBase = fullfile(projectRoot, 'Tables');
sourceModelsBase = projectRoot;

% Copy Chart Folders
chartSources = {
    fullfile(sourceScriptsBase, '_BaseData Scripts', 'BaseData Charts'),
    fullfile(sourceScriptsBase, '_BaseData Scripts', 'BaseData Quiver Plots'),
    fullfile(sourceScriptsBase, '_ZTCF Scripts', 'ZTCF Charts'),
    fullfile(sourceScriptsBase, '_ZTCF Scripts', 'ZTCF Quiver Plots'),
    fullfile(sourceScriptsBase, '_Delta Scripts', 'Delta Charts'),
    fullfile(sourceScriptsBase, '_Delta Scripts', 'Delta Quiver Plots'),
    fullfile(sourceScriptsBase, '_Comparison Scripts', 'Comparison Charts'),
    fullfile(sourceScriptsBase, '_Comparison Scripts', 'Comparison Quiver Plots'),
    fullfile(sourceScriptsBase, '_ZVCF Scripts', 'ZVCF Charts'),
    fullfile(sourceScriptsBase, '_ZVCF Scripts', 'ZVCF Quiver Plots')
};

for i = 1:length(chartSources)
    if exist(chartSources{i}, 'dir')
        fprintf('Copying charts from: %s\n', chartSources{i});
        copyfile(chartSources{i}, chartsFolder);
    else
        warning('Source chart folder not found: %s', chartSources{i});
    end
end

% Copy Model and Parameters files
modelSources = {
    fullfile(sourceModelsBase, 'GolfSwing3D_KineticallyDriven.slx'),
    fullfile(sourceModelsBase, 'ModelInputs.mat'),
    fullfile(sourceModelsBase, 'GolfSwing3D_ZVCF.slx'),
    fullfile(sourceModelsBase, 'ModelInputsZVCF.mat')
};

for i = 1:length(modelSources)
    if exist(modelSources{i}, 'file')
        fprintf('Copying model/parameter file: %s\n', modelSources{i});
        copyfile(modelSources{i}, modelsFolder);
    else
        warning('Source model/parameter file not found: %s', modelSources{i});
    end
end

% Copy Scripts folder (recursively)
if exist(sourceScriptsBase, 'dir')
    fprintf('Copying Scripts folder: %s\n', sourceScriptsBase);
    copyfile(sourceScriptsBase, scriptsFolder);
else
    warning('Source Scripts folder not found: %s', sourceScriptsBase);
end

% Copy Table files
tableSources = {
    fullfile(sourceTablesBase, 'BASEQ.mat'),
    fullfile(sourceTablesBase, 'ZTCFQ.mat'),
    fullfile(sourceTablesBase, 'DELTAQ.mat'),
    fullfile(sourceTablesBase, 'ZVCFTable.mat'),
    fullfile(sourceTablesBase, 'ZVCFTableQ.mat'),
    fullfile(sourceTablesBase, 'ClubQuiverAlphaReversal.mat'),
    fullfile(sourceTablesBase, 'ClubQuiverMaxCHS.mat'),
    fullfile(sourceTablesBase, 'ClubQuiverZTCFAlphaReversal.mat'),
    fullfile(sourceTablesBase, 'ClubQuiverDELTAAlphaReversal.mat'),
    fullfile(sourceTablesBase, 'SummaryTable.mat')
};

for i = 1:length(tableSources)
    if exist(tableSources{i}, 'file')
        fprintf('Copying table file: %s\n', tableSources{i});
        copyfile(tableSources{i}, tablesFolder);
    else
        warning('Source table file not found: %s', tableSources{i});
    end
end

% Archive all .m scripts into one .txt snapshot
timestamp = datestr(now, 'yyyy-mm-dd_HH-MM-SS');
archiveFile = fullfile(archiveFolder, [caseID '_Scripts_' timestamp '.txt']);
pack_project_no_prompt(projectRoot, archiveFile);

fprintf('File copying and script archiving to results folder complete.\n');
end

%%% END FILE: generateResultsFolder3D.m %%%

%%% START FILE: generateSummaryTableAndQuiverData3D.m %%%
function [SummaryTable, ClubQuiverAlphaReversal, ClubQuiverMaxCHS, ClubQuiverZTCFAlphaReversal, ClubQuiverDELTAAlphaReversal] = generateSummaryTableAndQuiverData3D(BASEQ, ZTCFQ, DELTAQ)
% GENERATESUMMARYTABLEANDQUIVERDATA3D Calculates key values and generates data for quiver plots.
%   [SummaryTable, ClubQuiverAlphaReversal, ClubQuiverMaxCHS, ...
%    ClubQuiverZTCFAlphaReversal, ClubQuiverDELTAAlphaReversal] = ...
%    GENERATESUMMARYTABLEANDQUIVERDATA3D(BASEQ, ZTCFQ, DELTAQ)
%   Analyzes the BASEQ, ZTCFQ, and DELTAQ tables (expected on a uniform
%   time grid) to find maximum speeds, times of specific events (like
%   alpha reversal and zero AoA), and generates data structures containing
%   coordinates and vectors at these key times for potential quiver plotting.
%
%   This function is the converted version of SCRIPT_TableofValues_3D.m.
%
%   Input:
%       BASEQ  - Table containing Base data on a uniform time grid.
%       ZTCFQ  - Table containing ZTCF data on the same uniform time grid.
%       DELTAQ - Table containing Delta data on the same uniform time grid.
%                These tables are expected to contain various kinematic
%                and force/torque data, including 'Time', 'CHS (mph)',
%                'Hand Speed (mph)', 'BaseAV', 'ChestAV', 'LScapAV',
%                'LUpperArmAV', 'LForearmAV', 'ClubhandleAV',
%                'EquivalentMidpointCoupleLocal', 'AoA', and position/vector
%                components for 'Butt', 'RW', 'CH', 'Gripdx/dy/dz', 'Shaftdx/dy/dz'.
%
%   Output:
%       SummaryTable              - Table summarizing key values (max speeds, event times).
%       ClubQuiverAlphaReversal   - Struct with data for club/shaft quiver at Base Alpha Reversal time.
%       ClubQuiverMaxCHS          - Struct with data for club/shaft quiver at Base Max CHS time.
%       ClubQuiverZTCFAlphaReversal - Struct with data for club/shaft quiver at ZTCF Alpha Reversal time.
%       ClubQuiverDELTAAlphaReversal - Struct with data for club/shaft quiver at DELTA Alpha Reversal time.

% Initialize outputs
SummaryTable = table();
ClubQuiverMaxCHS = struct();
ClubQuiverAlphaReversal = struct();
ClubQuiverZTCFAlphaReversal = struct();
ClubQuiverDELTAAlphaReversal = struct();

% --- Calculate Maximum Speeds and the Times They Occur (from BASEQ) ---

% Check if required columns exist in BASEQ for speed calculations
requiredSpeedCols_BASEQ = {'CHS (mph)', 'Hand Speed (mph)', 'BaseAV', 'ChestAV', 'LScapAV', 'LUpperArmAV', 'LForearmAV', 'ClubhandleAV'};
if all(ismember(requiredSpeedCols_BASEQ, BASEQ.Properties.VariableNames))

    % Generate CHS Array
    CHS = BASEQ{:, "CHS (mph)"};
    % Find Max CHS Value
    MaxCHS = max(CHS);
    SummaryTable.("MaxCHS") = MaxCHS;

    % Generate Hand Speed Array
    HS = BASEQ{:, "Hand Speed (mph)"};
    % Find Max Hand Speed Value
    MaxHandSpeed = max(HS);
    SummaryTable.("MaxHandSpeed") = MaxHandSpeed;

    % Generate Hip Angular Velocity (AV) Array
    HipAV = BASEQ{:, "BaseAV"};
    % Find Max Hip AV Value
    MaxHipAV = max(HipAV);
    SummaryTable.("MaxHipAV") = MaxHipAV;

    % Generate Torso Angular Velocity (AV) Array
    TorsoAV = BASEQ{:, "ChestAV"};
    % Find Max Torso AV Value
    MaxTorsoAV = max(TorsoAV);
    SummaryTable.("MaxTorsoAV") = MaxTorsoAV;

    % Generate LScap Angular Velocity (AV) Array
    LScapAV = BASEQ{:, "LScapAV"};
    % Find Max LScap AV Value
    MaxLScapAV = max(LScapAV);
    SummaryTable.("MaxLScapAV") = MaxLScapAV;

    % Generate LUpperArm Angular Velocity (AV) Array
    LUpperArmAV = BASEQ{:, "LUpperArmAV"};
    % Find Max LUpperArm AV Value
    MaxLUpperArmAV = max(LUpperArmAV);
    SummaryTable.("MaxLUpperArmAV") = MaxLUpperArmAV;

    % Generate LForearm Angular Velocity (AV) Array
    LForearmAV = BASEQ{:, "LForearmAV"};
    % Find Max LForearm AV Value
    MaxLForearmAV = max(LForearmAV);
    SummaryTable.("MaxLForearmAV") = MaxLForearmAV;

    % Generate Club Angular Velocity (AV) Array
    ClubAV = BASEQ{:, "ClubhandleAV"};
    % Find Max Club AV Value
    MaxClubAV = max(ClubAV);
    SummaryTable.("MaxClubAV") = MaxClubAV;

    % Find the row in the table where each maximum occurs
    CHSMaxRow = find(CHS == MaxCHS, 1);
    HSMaxRow = find(HS == MaxHandSpeed, 1);
    HipAVMaxRow = find(HipAV == MaxHipAV, 1);
    TorsoAVMaxRow = find(TorsoAV == MaxTorsoAV, 1);
    LScapAVMaxRow = find(LScapAV == MaxLScapAV, 1);
    LUpperArmAVMaxRow = find(LUpperArmAV == MaxLUpperArmAV, 1);
    LForearmAVMaxRow = find(LForearmAV == MaxLForearmAV, 1);
    ClubAVMaxRow = find(ClubAV == MaxClubAV, 1);

    % Find the time in the table where the maximum occurs
    CHSMaxTime = BASEQ.Time(CHSMaxRow, 1);
    SummaryTable.("CHSMaxTime") = CHSMaxTime;

    HandSpeedMaxTime = BASEQ.Time(HSMaxRow, 1);
    SummaryTable.("HandSpeedMaxTime") = HandSpeedMaxTime;

    HipAVMaxTime = BASEQ.Time(HipAVMaxRow, 1);
    SummaryTable.("HipAVMaxTime") = HipAVMaxTime;

    TorsoAVMaxTime = BASEQ.Time(TorsoAVMaxRow, 1);
    SummaryTable.("TorsoAVMaxTime") = TorsoAVMaxTime;

    LScapAVMaxTime = BASEQ.Time(LScapAVMaxRow, 1);
    SummaryTable.("LScapAVMaxTime") = LScapAVMaxTime;

    LUpperArmAVMaxTime = BASEQ.Time(LUpperArmAVMaxRow, 1);
    SummaryTable.("LUpperArmAVMaxTime") = LUpperArmAVMaxTime;

    LForearmAVMaxTime = BASEQ.Time(LForearmAVMaxRow, 1);
    SummaryTable.("LForearmAVMaxTime") = LForearmAVMaxTime;

    ClubAVMaxTime = BASEQ.Time(ClubAVMaxRow, 1);
    SummaryTable.("MaxClubAVTime") = ClubAVMaxTime; % Renamed from ClubAVMaxTime for clarity

    % Find AoA at time of maximum CHS
    if ismember('AoA', BASEQ.Properties.VariableNames)
        AoAatMaxCHS = BASEQ.AoA(CHSMaxRow, 1);
        SummaryTable.("AoAatMaxCHS") = AoAatMaxCHS;
    else
        warning('Required data column "AoA" not found in BASEQ for AoAatMaxCHS.');
        SummaryTable.("AoAatMaxCHS") = NaN;
    end

else
    warning('Required columns for speed calculations not found in BASEQ.');
    % Initialize speed/time fields in SummaryTable to NaN
    speedFields = {'MaxCHS', 'MaxHandSpeed', 'HipAV', 'TorsoAV', 'LScapAV', 'LUpperArmAV', 'LForearmAV', 'ClubAV'};
    timeFields = {'CHSMaxTime', 'HandSpeedMaxTime', 'HipAVMaxTime', 'TorsoAVMaxTime', 'LScapAVMaxTime', 'LUpperArmAVMaxTime', 'LForearmAVMaxTime', 'MaxClubAVTime'};
     for k = 1:length(speedFields)
         SummaryTable.(speedFields{k}) = NaN;
     end
     for k = 1:length(timeFields)
         SummaryTable.(timeFields{k}) = NaN;
     end
     SummaryTable.("AoAatMaxCHS") = NaN;
end


% --- Calculate Times of Specific Events ---

% Calculate the time that the equivalent midpoint couple goes negative in late downswing (BaseData)
% Interpolate where the 3rd component of EquivalentMidpointCoupleLocal crosses zero.
% Starting interpolation from index 50 as in original script to avoid startup effects.
% Ensure the data column exists and has enough points.
if ismember('EquivalentMidpointCoupleLocal', BASEQ.Properties.VariableNames) && height(BASEQ) >= 50
    timeData = BASEQ.Time(50:end, 1);
    coupleData = BASEQ.EquivalentMidpointCoupleLocal(50:end, 3); % Assuming 3rd component is relevant
    % Check if interpolation range is valid (at least 2 points) and data is not constant
    if length(timeData) >= 2 && range(coupleData) > 0
         TimeofAlphaReversal = interp1(coupleData, timeData, 0.0, 'linear', 'extrap'); % Use 'extrap' if zero is outside range
         SummaryTable.("TimeofAlphaReversal") = TimeofAlphaReversal;
    else
         warning('Not enough varying data points to calculate TimeofAlphaReversal for BASEQ.');
         SummaryTable.("TimeofAlphaReversal") = NaN;
    end
else
    warning('Required data column "EquivalentMidpointCoupleLocal" not found or not enough data in BASEQ for TimeofAlphaReversal.');
    SummaryTable.("TimeofAlphaReversal") = NaN;
end

% Calculate the time that the ZTCF equivalent midpoint couple goes negative.
if ismember('EquivalentMidpointCoupleLocal', ZTCFQ.Properties.VariableNames) && height(ZTCFQ) >= 50
     timeData_ZTCF = ZTCFQ.Time(50:end, 1);
     coupleData_ZTCF = ZTCFQ.EquivalentMidpointCoupleLocal(50:end, 3);
     if length(timeData_ZTCF) >= 2 && range(coupleData_ZTCF) > 0
        TimeofZTCFAlphaReversal = interp1(coupleData_ZTCF, timeData_ZTCF, 0.0, 'linear', 'extrap');
        SummaryTable.("TimeofZTCFAlphaReversal") = TimeofZTCFAlphaReversal;
     else
        warning('Not enough varying data points to calculate TimeofZTCFAlphaReversal for ZTCFQ.');
        SummaryTable.("TimeofZTCFAlphaReversal") = NaN;
     end
else
    warning('Required data column "EquivalentMidpointCoupleLocal" not found or not enough data in ZTCFQ for TimeofZTCFAlphaReversal.');
    SummaryTable.("TimeofZTCFAlphaReversal") = NaN;
end

% Calculate the time that the DELTA equivalent midpoint couple goes negative.
if ismember('EquivalentMidpointCoupleLocal', DELTAQ.Properties.VariableNames) && height(DELTAQ) >= 50
    timeData_DELTA = DELTAQ.Time(50:end, 1);
    coupleData_DELTA = DELTAQ.EquivalentMidpointCoupleLocal(50:end, 3);
    if length(timeData_DELTA) >= 2 && range(coupleData_DELTA) > 0
        TimeofDELTAAlphaReversal = interp1(coupleData_DELTA, timeData_DELTA, 0.0, 'linear', 'extrap');
        SummaryTable.("TimeofDELTAAlphaReversal") = TimeofDELTAAlphaReversal;
    else
        warning('Not enough varying data points to calculate TimeofDELTAAlphaReversal for DELTAQ.');
        SummaryTable.("TimeofDELTAAlphaReversal") = NaN;
    end
else
    warning('Required data column "EquivalentMidpointCoupleLocal" not found or not enough data in DELTAQ for TimeofDELTAAlphaReversal.');
    SummaryTable.("TimeofDELTAAlphaReversal") = NaN;
end


% Generate a table of the times when the function of interest (f) crosses zero (for AoA).
% Assumes 'AoA' column exists in BASEQ.
if ismember('AoA', BASEQ.Properties.VariableNames)
    f = BASEQ.AoA;
    t = BASEQ.Time;

    % Find indices where the sign changes
    idx = find(f(2:end) .* f(1:end-1) < 0);

    % Interpolate to find the exact time of zero crossing for each sign change
    t_zero = zeros(size(idx));
    for i = 1:numel(idx)
        j = idx(i); % Index in the original vector where sign change starts
        % Interpolate between point j and j+1
        t_zero(i) = interp1(f(j:j+1), t(j:j+1), 0.0, 'linear');
    end

    % Time of Zero AoA that Occurs Last (assuming downswing is the relevant phase)
    if ~isempty(t_zero)
        TimeofZeroAoA = max(t_zero); % Find the latest zero crossing
        SummaryTable.("TimeofZeroAoA") = TimeofZeroAoA;

        % CHS at time of zero AoA (interpolate CHS at this specific time)
        if ismember('CHS (mph)', BASEQ.Properties.VariableNames) && ~isnan(TimeofZeroAoA)
             CHSZeroAoA = interp1(BASEQ.Time, BASEQ.("CHS (mph)"), TimeofZeroAoA, 'linear', 'extrap');
             SummaryTable.("CHSZeroAoA") = CHSZeroAoA;
        else
             warning('Required data column "CHS (mph)" not found in BASEQ or TimeofZeroAoA invalid for CHSZeroAoA.');
             SummaryTable.("CHSZeroAoA") = NaN;
        end
    else
        warning('No zero crossing found for AoA in BASEQ.');
        SummaryTable.("TimeofZeroAoA") = NaN;
        SummaryTable.("CHSZeroAoA") = NaN;
    end
else
    warning('Required data column "AoA" not found in BASEQ.');
    SummaryTable.("TimeofZeroAoA") = NaN;
    SummaryTable.("CHSZeroAoA") = NaN;
end


% --- Generate Data Needed for Quivers at Specific Times ---
% These structs will hold position and vector data at key moments for plotting.
% Interpolate data from BASEQ, ZTCFQ, DELTAQ at the calculated times.

% Required columns for quiver data generation
requiredQuiverCols = {'Buttx', 'Butty', 'Buttz', 'Gripdx', 'Gripdy', 'Gripdz', 'RWx', 'RWy', 'RWz', 'Shaftdx', 'Shaftdy', 'Shaftdz'};


% Find Data Needed for Grip and Shaft Quivers at Time of Max CHS (from BASEQ)
if isfield(SummaryTable, 'CHSMaxTime') && ~isnan(SummaryTable.CHSMaxTime) && all(ismember(requiredQuiverCols, BASEQ.Properties.VariableNames))
    t_maxCHS = SummaryTable.CHSMaxTime;
    ClubQuiverMaxCHS.("ButtxMaxCHS") = interp1(BASEQ.Time, BASEQ.("Buttx"), t_maxCHS, 'linear', 'extrap');
    ClubQuiverMaxCHS.("ButtyMaxCHS") = interp1(BASEQ.Time, BASEQ.("Butty"), t_maxCHS, 'linear', 'extrap');
    ClubQuiverMaxCHS.("ButtzMaxCHS") = interp1(BASEQ.Time, BASEQ.("Buttz"), t_maxCHS, 'linear', 'extrap');
    ClubQuiverMaxCHS.("GripdxMaxCHS") = interp1(BASEQ.Time, BASEQ.("Gripdx"), t_maxCHS, 'linear', 'extrap');
    ClubQuiverMaxCHS.("GripdyMaxCHS") = interp1(BASEQ.Time, BASEQ.("Gripdy"), t_maxCHS, 'linear', 'extrap');
    ClubQuiverMaxCHS.("GripdzMaxCHS") = interp1(BASEQ.Time, BASEQ.("Gripdz"), t_maxCHS, 'linear', 'extrap');
    ClubQuiverMaxCHS.("RWxMaxCHS") = interp1(BASEQ.Time, BASEQ.("RWx"), t_maxCHS, 'linear', 'extrap');
    ClubQuiverMaxCHS.("RWyMaxCHS") = interp1(BASEQ.Time, BASEQ.("RWy"), t_maxCHS, 'linear', 'extrap');
    ClubQuiverMaxCHS.("RWzMaxCHS") = interp1(BASEQ.Time, BASEQ.("RWz"), t_maxCHS, 'linear', 'extrap');
    ClubQuiverMaxCHS.("ShaftdxMaxCHS") = interp1(BASEQ.Time, BASEQ.("Shaftdx"), t_maxCHS, 'linear', 'extrap');
    ClubQuiverMaxCHS.("ShaftdyMaxCHS") = interp1(BASEQ.Time, BASEQ.("Shaftdy"), t_maxCHS, 'linear', 'extrap');
    ClubQuiverMaxCHS.("ShaftdzMaxCHS") = interp1(BASEQ.Time, BASEQ.("Shaftdz"), t_maxCHS, 'linear', 'extrap');
else
    warning('Cannot generate ClubQuiverMaxCHS data: CHSMaxTime invalid or required columns missing in BASEQ.');
    % Initialize fields to NaN
    for k = 1:length(requiredQuiverCols)
        ClubQuiverMaxCHS.(requiredQuiverCols{k} + "MaxCHS") = NaN;
    end
end


% Find Data Needed for Grip and Shaft Quivers at Time of Alpha Reversal (from BASEQ)
if isfield(SummaryTable, 'TimeofAlphaReversal') && ~isnan(SummaryTable.TimeofAlphaReversal) && all(ismember(requiredQuiverCols, BASEQ.Properties.VariableNames))
    t_alphaRev = SummaryTable.TimeofAlphaReversal;
    ClubQuiverAlphaReversal.("ButtxAlphaReversal") = interp1(BASEQ.Time, BASEQ.("Buttx"), t_alphaRev, 'linear', 'extrap');
    ClubQuiverAlphaReversal.("ButtyAlphaReversal") = interp1(BASEQ.Time, BASEQ.("Butty"), t_alphaRev, 'linear', 'extrap');
    ClubQuiverAlphaReversal.("ButtzAlphaReversal") = interp1(BASEQ.Time, BASEQ.("Buttz"), t_alphaRev, 'linear', 'extrap');
    ClubQuiverAlphaReversal.("GripdxAlphaReversal") = interp1(BASEQ.Time, BASEQ.("Gripdx"), t_alphaRev, 'linear', 'extrap');
    ClubQuiverAlphaReversal.("GripdyAlphaReversal") = interp1(BASEQ.Time, BASEQ.("Gripdy"), t_alphaRev, 'linear', 'extrap');
    ClubQuiverAlphaReversal.("GripdzAlphaReversal") = interp1(BASEQ.Time, BASEQ.("Gripdz"), t_alphaRev, 'linear', 'extrap');
    ClubQuiverAlphaReversal.("RWxAlphaReversal") = interp1(BASEQ.Time, BASEQ.("RWx"), t_alphaRev, 'linear', 'extrap');
    ClubQuiverAlphaReversal.("RWyAlphaReversal") = interp1(BASEQ.Time, BASEQ.("RWy"), t_alphaRev, 'linear', 'extrap');
    ClubQuiverAlphaReversal.("RWzAlphaReversal") = interp1(BASEQ.Time, BASEQ.("RWz"), t_alphaRev, 'linear', 'extrap');
    ClubQuiverAlphaReversal.("ShaftdxAlphaReversal") = interp1(BASEQ.Time, BASEQ.("Shaftdx"), t_alphaRev, 'linear', 'extrap');
    ClubQuiverAlphaReversal.("ShaftdyAlphaReversal") = interp1(BASEQ.Time, BASEQ.("Shaftdy"), t_alphaRev, 'linear', 'extrap');
    ClubQuiverAlphaReversal.("ShaftdzAlphaReversal") = interp1(BASEQ.Time, BASEQ.("Shaftdz"), t_alphaRev, 'linear', 'extrap');
else
    warning('Cannot generate ClubQuiverAlphaReversal data: TimeofAlphaReversal invalid or required columns missing in BASEQ.');
     % Initialize fields to NaN
     for k = 1:length(requiredQuiverCols)
        ClubQuiverAlphaReversal.(requiredQuiverCols{k} + "AlphaReversal") = NaN;
     end
end


% Find Data Needed for Grip and Shaft Quivers at Time of ZTCF Alpha Reversal (from ZTCFQ)
if isfield(SummaryTable, 'TimeofZTCFAlphaReversal') && ~isnan(SummaryTable.TimeofZTCFAlphaReversal) && all(ismember(requiredQuiverCols, ZTCFQ.Properties.VariableNames))
    t_ztcfAlphaRev = SummaryTable.TimeofZTCFAlphaReversal;
    ClubQuiverZTCFAlphaReversal.("ButtxZTCFAlphaReversal") = interp1(ZTCFQ.Time, ZTCFQ.("Buttx"), t_ztcfAlphaRev, 'linear', 'extrap');
    ClubQuiverZTCFAlphaReversal.("ButtyZTCFAlphaReversal") = interp1(ZTCFQ.Time, ZTCFQ.("Butty"), t_ztcfAlphaRev, 'linear', 'extrap');
    ClubQuiverZTCFAlphaReversal.("ButtzZTCFAlphaReversal") = interp1(ZTCFQ.Time, ZTCFQ.("Buttz"), t_ztcfAlphaRev, 'linear', 'extrap');
    ClubQuiverZTCFAlphaReversal.("GripdxZTCFAlphaReversal") = interp1(ZTCFQ.Time, ZTCFQ.("Gripdx"), t_ztcfAlphaRev, 'linear', 'extrap');
    ClubQuiverZTCFAlphaReversal.("GripdyZTCFAlphaReversal") = interp1(ZTCFQ.Time, ZTCFQ.("Gripdy"), t_ztcfAlphaRev, 'linear', 'extrap');
    ClubQuiverZTCFAlphaReversal.("GripdzZTCFAlphaReversal") = interp1(ZTCFQ.Time, ZTCFQ.("Gripdz"), t_ztcfAlphaRev, 'linear', 'extrap');
    ClubQuiverZTCFAlphaReversal.("RWxZTCFAlphaReversal") = interp1(ZTCFQ.Time, ZTCFQ.("RWx"), t_ztcfAlphaRev, 'linear', 'extrap');
    ClubQuiverZTCFAlphaReversal.("RWyZTCFAlphaReversal") = interp1(ZTCFQ.Time, ZTCFQ.("RWy"), t_ztcfAlphaRev, 'linear', 'extrap');
    ClubQuiverZTCFAlphaReversal.("RWzZTCFAlphaReversal") = interp1(ZTCFQ.Time, ZTCFQ.("RWz"), t_ztcfAlphaRev, 'linear', 'extrap');
    ClubQuiverZTCFAlphaReversal.("ShaftdxZTCFAlphaReversal") = interp1(ZTCFQ.Time, ZTCFQ.("Shaftdx"), t_ztcfAlphaRev, 'linear', 'extrap');
    ClubQuiverZTCFAlphaReversal.("ShaftdyZTCFAlphaReversal") = interp1(ZTCFQ.Time, ZTCFQ.("Shaftdy"), t_ztcfAlphaRev, 'linear', 'extrap');
    ClubQuiverZTCFAlphaReversal.("ShaftdzZTCFAlphaReversal") = interp1(ZTCFQ.Time, ZTCFQ.("Shaftdz"), t_ztcfAlphaRev, 'linear', 'extrap');
else
    warning('Cannot generate ClubQuiverZTCFAlphaReversal data: TimeofZTCFAlphaReversal invalid or required columns missing in ZTCFQ.');
     % Initialize fields to NaN
     for k = 1:length(requiredQuiverCols)
        ClubQuiverZTCFAlphaReversal.(requiredQuiverCols{k} + "ZTCFAlphaReversal") = NaN;
     end
end


% Find Data Needed for Grip and Shaft Quivers at Time of DELTA Alpha Reversal (from DELTAQ)
if isfield(SummaryTable, 'TimeofDELTAAlphaReversal') && ~isnan(SummaryTable.TimeofDELTAAlphaReversal) && all(ismember(requiredQuiverCols, DELTAQ.Properties.VariableNames))
    t_deltaAlphaRev = SummaryTable.TimeofDELTAAlphaReversal;
    ClubQuiverDELTAAlphaReversal.("ButtxDELTAAlphaReversal") = interp1(DELTAQ.Time, DELTAQ.("Buttx"), t_deltaAlphaRev, 'linear', 'extrap');
    ClubQuiverDELTAAlphaReversal.("ButtyDELTAAlphaReversal") = interp1(DELTAQ.Time, DELTAQ.("Butty"), t_deltaAlphaRev, 'linear', 'extrap');
    ClubQuiverDELTAAlphaReversal.("ButtzDELTAAlphaReversal") = interp1(DELTAQ.Time, DELTAQ.("Buttz"), t_deltaAlphaRev, 'linear', 'extrap');
    ClubQuiverDELTAAlphaReversal.("GripdxDELTAAlphaReversal") = interp1(DELTAQ.Time, DELTAQ.("Gripdx"), t_deltaAlphaRev, 'linear', 'extrap');
    ClubQuiverDELTAAlphaReversal.("GripdyDELTAAlphaReversal") = interp1(DELTAQ.Time, DELTAQ.("Gripdy"), t_deltaAlphaRev, 'linear', 'extrap');
    ClubQuiverDELTAAlphaReversal.("GripdzDELTAAlphaReversal") = interp1(DELTAQ.Time, DELTAQ.("Gripdz"), t_deltaAlphaRev, 'linear', 'extrap');
    ClubQuiverDELTAAlphaReversal.("RWxDELTAAlphaReversal") = interp1(DELTAQ.Time, DELTAQ.("RWx"), t_deltaAlphaRev, 'linear', 'extrap');
    ClubQuiverDELTAAlphaReversal.("RWyDELTAAlphaReversal") = interp1(DELTAQ.Time, DELTAQ.("RWy"), t_deltaAlphaRev, 'linear', 'extrap');
    ClubQuiverDELTAAlphaReversal.("RWzDELTAAlphaReversal") = interp1(DELTAQ.Time, DELTAQ.("RWz"), t_deltaAlphaRev, 'linear', 'extrap');
    ClubQuiverDELTAAlphaReversal.("ShaftdxDELTAAlphaReversal") = interp1(DELTAQ.Time, DELTAQ.("Shaftdx"), t_deltaAlphaRev, 'linear', 'extrap');
    ClubQuiverDELTAAlphaReversal.("ShaftdyDELTAAlphaReversal") = interp1(DELTAQ.Time, DELTAQ.("Shaftdy"), t_deltaAlphaRev, 'linear', 'extrap');
    ClubQuiverDELTAAlphaReversal.("ShaftdzDELTAAlphaReversal") = interp1(DELTAQ.Time, DELTAQ.("Shaftdz"), t_deltaAlphaRev, 'linear', 'extrap');
else
    warning('Cannot generate ClubQuiverDELTAAlphaReversal data: TimeofDELTAAlphaReversal invalid or required columns missing in DELTAQ.');
     % Initialize fields to NaN
     for k = 1:length(requiredQuiverCols)
        ClubQuiverDELTAAlphaReversal.(requiredQuiverCols{k} + "DELTAAlphaReversal") = NaN;
     end
end


% No need for explicit 'clear' statements within a function.
% All intermediate variables are local and cleared automatically.

end

%%% END FILE: generateSummaryTableAndQuiverData3D.m %%%

%%% START FILE: overlayQuiverForces.m %%%
function h = overlayQuiverForces(Pcell, Vcell, varargin)
% OVERLAYQUIVERFORCES - Overlay multiple 3D quiver datasets with consistent scaling and sliders
%
% Usage:
%   h = overlayQuiverForces({P1, P2, ...}, {V1, V2, ...}, ...);
%   Each P and V must be Nx3 or cell arrays of [X,Y,Z] and [U,V,W] vectors.
%
% Options (Name-Value Pairs):
%   'Colors'       : Cell array of RGB triplets
%   'Tags'         : Cell array of legend labels
%   'Landmark'     : [x y z] to shift all origins
%   'ShellType'    : 'none' | 'sphere' | 'plane'
%   'ShellAlpha'   : Transparency for shell (default: 0.1)
%   'Title'        : Plot title (default: 'Overlayed Vector Field')
%   'ShowSliders'  : true/false (default: true)

% ---------------- Input Handling ----------------
p = inputParser;
p.addParameter('Colors', {});
p.addParameter('Tags', {});
p.addParameter('Landmark', []);
p.addParameter('ShellType', 'none');
p.addParameter('ShellAlpha', 0.1);
p.addParameter('Title', 'Overlayed Vector Field');
p.addParameter('ShowSliders', true);
p.parse(varargin{:});
opts = p.Results;

numSets = length(Pcell);
assert(numSets == length(Vcell), 'Mismatched P/V cell input counts');

% Normalize inputs to Nx3 matrices
for i = 1:numSets
    if iscell(Pcell{i})
        Pcell{i} = [Pcell{i}{1}, Pcell{i}{2}, Pcell{i}{3}];
    end
    if iscell(Vcell{i})
        Vcell{i} = [Vcell{i}{1}, Vcell{i}{2}, Vcell{i}{3}];
    end
end

% ---------------- Compute Global Max Magnitude ----------------
allMags = [];
for i = 1:numSets
    V = Vcell{i};
    mags = sqrt(sum(V.^2, 2));
    allMags = [allMags; mags];
end
maxMag = max(allMags);
if maxMag == 0, maxMag = 1; end
sharedScale = 1 / maxMag;

% ---------------- Create Figure and Axes ----------------
h.fig = figure('Name','Overlayed Vector Field','Color','w');
h.ax = axes(h.fig); hold on; axis equal; grid on;
xlabel('X'); ylabel('Y'); zlabel('Z');
title(opts.Title);
h.shell = [];
h.quivers = gobjects(numSets, 1);
h.origins = cell(numSets, 1);
h.vectors = cell(numSets, 1);

% ---------------- Optional Landmark Shift ----------------
for i = 1:numSets
    P = Pcell{i};
    V = Vcell{i};
    if ~isempty(opts.Landmark)
        P = P - opts.Landmark;
    end
    h.origins{i} = P;
    h.vectors{i} = V;
    color = [0 0 0];
    if i <= length(opts.Colors)
        color = opts.Colors{i};
    end
    tag = "";
    if i <= length(opts.Tags)
        tag = opts.Tags{i};
    end
    h.quivers(i) = quiver3(h.ax, NaN, NaN, NaN, NaN, NaN, NaN, sharedScale, 'LineWidth', 1.5, 'Color', color);
    if tag ~= ""
        h.quivers(i).DisplayName = tag;
    end
end

if ~isempty(opts.Tags)
    legend(h.ax, 'show');
end

% ---------------- Draw Shell Once ----------------
if ~strcmpi(opts.ShellType, 'none')
    allX = cell2mat(cellfun(@(p)p(:,1), h.origins, 'UniformOutput', false));
    allY = cell2mat(cellfun(@(p)p(:,2), h.origins, 'UniformOutput', false));
    allZ = cell2mat(cellfun(@(p)p(:,3), h.origins, 'UniformOutput', false));
    switch lower(opts.ShellType)
        case 'sphere'
            [sx, sy, sz] = sphere(30);
            r = max(range([allX; allY; allZ])) / 3;
            cx = mean(allX); cy = mean(allY); cz = mean(allZ);
            h.shell = surf(h.ax, r*sx+cx, r*sy+cy, r*sz+cz, 'FaceAlpha', opts.ShellAlpha, ...
                          'EdgeColor','none','FaceColor',[0.5 0.8 1]);
        case 'plane'
            [px, py] = meshgrid(linspace(min(allX),max(allX),20), ...
                                 linspace(min(allY),max(allY),20));
            zVal = mean(allZ);
            h.shell = surf(h.ax, px, py, zVal*ones(size(px)), 'FaceAlpha', opts.ShellAlpha, ...
                          'EdgeColor','none','FaceColor',[0.8 0.5 1]);
    end
end

% ---------------- Sliders (Optional) ----------------
h.scaleSlider = [];
h.densitySlider = [];
if opts.ShowSliders
    h.panel = uipanel(h.fig, 'Position', [0.01 0.01 0.98 0.10], 'Title', 'Vector Controls');
    h.scaleSlider = uicontrol(h.panel, 'Style','slider', 'Min', 0.1, 'Max', 3.0, ...
        'Value', 1.0, 'Units','normalized', 'Position',[0.02 0.55 0.96 0.4], ...
        'Callback', @(s,~) updateOverlayQuivers(h, sharedScale));
    h.densitySlider = uicontrol(h.panel, 'Style','slider', 'Min', 1, 'Max', 100, ...
        'Value', min(30, size(h.origins{1},1)), 'Units','normalized', 'Position',[0.02 0.05 0.96 0.4], ...
        'Callback', @(s,~) updateOverlayQuivers(h, sharedScale));
end

updateOverlayQuivers(h, sharedScale);
end

function updateOverlayQuivers(h, baseScale)
    scaleFactor = 1.0;
    if isfield(h, 'scaleSlider') && isvalid(h.scaleSlider)
        scaleFactor = get(h.scaleSlider, 'Value');
    end
    n = inf;
    if isfield(h, 'densitySlider') && isvalid(h.densitySlider)
        n = round(get(h.densitySlider, 'Value'));
    end
    for i = 1:length(h.quivers)
        if isvalid(h.quivers(i))
            X = h.origins{i};
            V = h.vectors{i};
            idx = round(linspace(1, size(X,1), min(n, size(X,1))));
            set(h.quivers(i), 'XData', X(idx,1), 'YData', X(idx,2), 'ZData', X(idx,3), ...
                              'UData', V(idx,1), 'VData', V(idx,2), 'WData', V(idx,3), ...
                              'AutoScaleFactor', baseScale * scaleFactor);
        end
    end
end

%%% END FILE: overlayQuiverForces.m %%%

%%% START FILE: runZvcfSingleTime.m %%%
function zvcfDataTable = runZvcfSingleTime(simTime, baseDataTable, zvcfModelName)
% RUNZVCFSINGLETIME Runs a single ZVCF simulation at a specified time point.
%   zvcfDataTable = RUNZVCFSINGLETIME(simTime, baseDataTable, zvcfModelName)
%   Runs the ZVCF model at a specific time point 'simTime'. It configures
%   the ZVCF model's initial positions and constant joint torques by
%   interpolating values from the provided 'baseDataTable' at 'simTime'.
%   The function then runs a short simulation of the ZVCF model and returns
%   the simulation output data as a table.
%
%   This function is the converted version of SCRIPT_ZVCF_SingleTime_3D.m.
%
%   Input:
%       simTime       - The specific time point (scalar) at which to
%                       configure and run the ZVCF simulation (e.g., 0.20).
%       baseDataTable - A table containing Base data (positions and joint
%                       torques) on a time grid that spans 'simTime'.
%                       Expected columns include 'Time', 'HipTorqueZInput',
%                       'TorsoTorqueInput', etc., and 'HipPositionZ',
%                       'TorsoPosition', etc. (matching your 3D model outputs).
%       zvcfModelName - A string specifying the name of the ZVCF Simulink
%                       model (e.g., 'GolfSwing3D_ZVCF').
%
%   Output:
%       zvcfDataTable - A table containing the simulation output data from
%                       the short ZVCF run, generated by generateDataTable3D.
%                       Returns an empty table if simulation fails or data extraction fails.

% Initialize output table
zvcfDataTable = table();

% --- Check Inputs ---
if ~istable(baseDataTable) || isempty(baseDataTable) || ~ismember('Time', baseDataTable.Properties.VariableNames)
    error('Invalid baseDataTable input. Must be a non-empty table with a ''Time'' column.');
end

if ~isscalar(simTime) || ~isnumeric(simTime)
    error('Invalid simTime input. Must be a numeric scalar.');
end

if ~ischar(zvcfModelName) && ~isstring(zvcfModelName)
    error('Invalid zvcfModelName input. Must be a string.');
end

% Check if simTime is within the range of baseDataTable.Time
if simTime < min(baseDataTable.Time) || simTime > max(baseDataTable.Time)
    warning('simTime (%g) is outside the range of baseDataTable.Time [%g, %g]. Interpolation will extrapolate.', ...
            simTime, min(baseDataTable.Time), max(baseDataTable.Time));
end

% --- Load and Configure ZVCF Model ---

% Load the ZVCF model if it's not already loaded
if ~bdIsLoaded(zvcfModelName)
    try
        load_system(zvcfModelName);
    catch ME
        error('Could not load Simulink model "%s": %s', zvcfModelName, ME.message);
    end
end

% Get the model workspace
mdlWks_zvcf = get_param(zvcfModelName, 'ModelWorkspace');

% Create a SimulationInput object for this single run
in_zvcf = Simulink.SimulationInput(zvcfModelName);

% Set up ZVCF model simulation parameters on the SimulationInput object
% These override settings in the model's configuration parameters for this run
in_zvcf = in_zvcf.setStopTime(0.05); % Set the stop time for the short ZVCF simulation run
in_zvcf = in_zvcf.setFastRestart('off'); % Ensure Fast Restart is off for this model/run
in_zvcf = in_zvcf.setMaxStep(0.001); % Set maximum time step

% --- Interpolate Inputs from BaseData and Configure ZVCF Model ---
% Read the joint torque and position values from BaseData at simTime
% These values will be used as constant inputs and initial positions for the ZVCF model
% NOTE: Verify these column names match your 3D model's logged outputs
% NOTE: Verify units (radians vs. degrees) expected by your ZVCF model parameters

try
    % Interpolate Torque Inputs from BaseData
    hipJointTorque = interp1(baseDataTable.Time, baseDataTable.HipTorqueZInput, simTime, 'linear', 'extrap'); % Assuming Z is primary input axis
    torsoJointTorque = interp1(baseDataTable.Time, baseDataTable.TorsoTorqueInput, simTime, 'linear', 'extrap'); % Assuming single input
    lscapJointTorqueX = interp1(baseDataTable.Time, baseDataTable.LScapTorqueXInput, simTime, 'linear', 'extrap');
    lscapJointTorqueY = interp1(baseDataTable.Time, baseDataTable.LScapTorqueYInput, simTime, 'linear', 'extrap');
    rscapJointTorqueX = interp1(baseDataTable.Time, baseDataTable.RScapTorqueXInput, simTime, 'linear', 'extrap');
    rscapJointTorqueY = interp1(baseDataTable.Time, baseDataTable.RScapTorqueYInput, simTime, 'linear', 'extrap');
    lshoulderJointTorqueX = interp1(baseDataTable.Time, baseDataTable.LSTorqueXInput, simTime, 'linear', 'extrap');
    lshoulderJointTorqueY = interp1(baseDataTable.Time, baseDataTable.LSTorqueYInput, simTime, 'linear', 'extrap');
    lshoulderJointTorqueZ = interp1(baseDataTable.Time, baseDataTable.LSTorqueZInput, simTime, 'linear', 'extrap');
    rshoulderJointTorqueX = interp1(baseDataTable.Time, baseDataTable.RSTorqueXInput, simTime, 'linear', 'extrap');
    rshoulderJointTorqueY = interp1(baseDataTable.Time, baseDataTable.RSTorqueYInput, simTime, 'linear', 'extrap');
    rshoulderJointTorqueZ = interp1(baseDataTable.Time, baseDataTable.RSTorqueZInput, simTime, 'linear', 'extrap');
    lelbowJointTorque = interp1(baseDataTable.Time, baseDataTable.LETorqueInput, simTime, 'linear', 'extrap'); % Assuming single input
    relbowJointTorque = interp1(baseDataTable.Time, baseDataTable.RETorqueInput, simTime, 'linear', 'extrap'); % Assuming single input
    lwristJointTorqueX = interp1(baseDataTable.Time, baseDataTable.LWTorqueXInput, simTime, 'linear', 'extrap');
    lwristJointTorqueY = interp1(baseDataTable.Time, baseDataTable.LWTorqueYInput, simTime, 'linear', 'extrap');
    rwristJointTorqueX = interp1(baseDataTable.Time, baseDataTable.RWTorqueXInput, simTime, 'linear', 'extrap');
    rwristJointTorqueY = interp1(baseDataTable.Time, baseDataTable.RWTorqueYInput, simTime, 'linear', 'extrap');

    % Interpolate Position Values from BaseData (for Initial Positions)
    % Convert to degrees if the ZVCF model parameters expect degrees (as in original script)
    hipPosition = interp1(baseDataTable.Time, baseDataTable.HipPositionZ, simTime, 'linear', 'extrap') * 180/pi; % Assuming Z position is relevant
    torsoPosition = interp1(baseDataTable.Time, baseDataTable.TorsoPosition, simTime, 'linear', 'extrap') * 180/pi; % Assuming single position
    lscapPositionX = interp1(baseDataTable.Time, baseDataTable.LScapPositionX, simTime, 'linear', 'extrap') * 180/pi;
    lscapPositionY = interp1(baseDataTable.Time, baseDataTable.LScapPositionY, simTime, 'linear', 'extrap') * 180/pi;
    rscapPositionX = interp1(baseDataTable.Time, baseDataTable.RScapPositionX, simTime, 'linear', 'extrap') * 180/pi;
    rscapPositionY = interp1(baseDataTable.Time, baseDataTable.RScapPositionY, simTime, 'linear', 'extrap') * 180/pi;
    lshoulderPositionX = interp1(baseDataTable.Time, baseDataTable.LSPositionX, simTime, 'linear', 'extrap') * 180/pi;
    lshoulderPositionY = interp1(baseDataTable.Time, baseDataTable.LSPositionY, simTime, 'linear', 'extrap') * 180/pi;
    lshoulderPositionZ = interp1(baseDataTable.Time, baseDataTable.LSPositionZ, simTime, 'linear', 'extrap') * 180/pi;
    rshoulderPositionX = interp1(baseDataTable.Time, baseDataTable.RSPositionX, simTime, 'linear', 'extrap') * 180/pi;
    rshoulderPositionY = interp1(baseDataTable.Time, baseDataTable.RSPositionY, simTime, 'linear', 'extrap') * 180/pi;
    rshoulderPositionZ = interp1(baseDataTable.Time, baseDataTable.RSPositionZ, simTime, 'linear', 'extrap') * 180/pi;
    lelbowPosition = interp1(baseDataTable.Time, baseDataTable.LEPosition, simTime, 'linear', 'extrap') * 180/pi; % Assuming single position
    relbowPosition = interp1(baseDataTable.Time, baseDataTable.REPosition, simTime, 'linear', 'extrap') * 180/pi; % Assuming single position
    lwristPositionX = interp1(baseDataTable.Time, baseDataTable.LWPositionX, simTime, 'linear', 'extrap') * 180/pi;
    lwristPositionY = interp1(baseDataTable.Time, baseDataTable.LWPositionY, simTime, 'linear', 'extrap') * 180/pi;
    rwristPositionX = interp1(baseDataTable.Time, baseDataTable.RWPositionX, simTime, 'linear', 'extrap') * 180/pi;
    rwristPositionY = interp1(baseDataTable.Time, baseDataTable.RWPositionY, simTime, 'linear', 'extrap') * 180/pi;

catch ME
    warning('Error interpolating data from baseDataTable at time %g: %s', simTime, ME.message);
    % Return empty table if interpolation fails due to missing columns
    close_system(zvcfModelName, 0); % Close model
    return; % Exit the function
end

% Assign interpolated torque values as constant inputs to the ZVCF model using setVariable
% NOTE: Ensure parameter names match your ZVCF model's input blocks/parameters
in_zvcf = in_zvcf.setVariable('JointTorqueHip', hipJointTorque);
in_zvcf = in_zvcf.setVariable('JointTorqueTorso', torsoJointTorque);
in_zvcf = in_zvcf.setVariable('JointTorqueLScapX', lscapJointTorqueX);
in_zvcf = in_zvcf.setVariable('JointTorqueLScapY', lscapJointTorqueY);
in_zvcf = in_zvcf.setVariable('JointTorqueRScapX', rscapJointTorqueX);
in_zvcf = in_zvcf.setVariable('JointTorqueRScapY', rscapJointTorqueY);
in_zvcf = in_zvcf.setVariable('JointTorqueLShoulderX', lshoulderJointTorqueX);
in_zvcf = in_zvcf.setVariable('JointTorqueLShoulderY', lshoulderJointTorqueY);
in_zvcf = in_zvcf.setVariable('JointTorqueLShoulderZ', lshoulderJointTorqueZ);
in_zvcf = in_zvcf.setVariable('JointTorqueRShoulderX', rshoulderJointTorqueX);
in_zvcf = in_zvcf.setVariable('JointTorqueRShoulderY', rshoulderJointTorqueY);
in_zvcf = in_zvcf.setVariable('JointTorqueRShoulderZ', rshoulderJointTorqueZ);
in_zvcf = in_zvcf.setVariable('JointTorqueLElbow', lelbowJointTorque);
in_zvcf = in_zvcf.setVariable('JointTorqueRElbow', relbowJointTorque);
in_zvcf = in_zvcf.setVariable('JointTorqueLWristX', lwristJointTorqueX);
in_zvcf = in_zvcf.setVariable('JointTorqueLWristY', lwristJointTorqueY);
in_zvcf = in_zvcf.setVariable('JointTorqueRWristX', rwristJointTorqueX);
in_zvcf = in_zvcf.setVariable('JointTorqueRWristY', rwristJointTorqueY);

% Assign interpolated position values as initial positions for the ZVCF model using setVariable
% Set initial velocities to zero using setVariable
% NOTE: Ensure parameter names match your ZVCF model's initial condition parameters
in_zvcf = in_zvcf.setVariable('HipStartPosition', hipPosition);
in_zvcf = in_zvcf.setVariable('HipStartVelocity', 0);
in_zvcf = in_zvcf.setVariable('TorsoStartPosition', torsoPosition);
in_zvcf = in_zvcf.setVariable('TorsoStartVelocity', 0);
in_zvcf = in_zvcf.setVariable('LScapStartPositionX', lscapPositionX);
in_zvcf = in_zvcf.setVariable('LScapStartVelocityX', 0);
in_zvcf = in_zvcf.setVariable('LScapStartPositionY', lscapPositionY);
in_zvcf = in_zvcf.setVariable('LScapStartVelocityY', 0);
in_zvcf = in_zvcf.setVariable('RScapStartPositionX', rscapPositionX);
in_zvcf = in_zvcf.setVariable('RScapStartVelocityX', 0);
in_zvcf = in_zvcf.setVariable('RScapStartPositionY', rscapPositionY);
in_zvcf = in_zvcf.setVariable('RScapStartVelocityY', 0);
in_zvcf = in_zvcf.setVariable('LShoulderStartPositionX', lshoulderPositionX);
in_zvcf = in_zvcf.setVariable('LShoulderStartVelocityX', 0);
in_zvcf = in_zvcf.setVariable('LShoulderStartPositionY', lshoulderPositionY);
in_zvcf = in_zvcf.setVariable('LShoulderStartVelocityY', 0);
in_zvcf = in_zvcf.setVariable('LShoulderStartPositionZ', lshoulderPositionZ);
in_zvcf = in_zvcf.setVariable('LShoulderStartVelocityZ', 0);
in_zvcf = in_zvcf.setVariable('RShoulderStartPositionX', rshoulderPositionX);
in_zvcf = in_zvcf.setVariable('RShoulderStartVelocityX', 0);
in_zvcf = in_zvcf.setVariable('RShoulderStartPositionY', rshoulderPositionY);
in_zvcf = in_zvcf.setVariable('RShoulderStartVelocityY', 0);
in_zvcf = in_zvcf.setVariable('RShoulderStartPositionZ', rshoulderPositionZ);
in_zvcf = in_zvcf.setVariable('RShoulderStartVelocityZ', 0);
in_zvcf = in_zvcf.setVariable('LElbowStartPosition', lelbowPosition);
in_zvcf = in_zvcf.setVariable('LElbowStartVelocity', 0);
in_zvcf = in_zvcf.setVariable('RElbowStartPosition', relbowPosition);
in_zvcf = in_zvcf.setVariable('RElbowStartVelocity', 0);
in_zvcf = in_zvcf.setVariable('LWristStartPositionX', lwristPositionX);
in_zvcf = in_zvcf.setVariable('LWristStartVelocityX', 0);
in_zvcf = in_zvcf.setVariable('LWristStartPositionY', lwristPositionY);
in_zvcf = in_zvcf.setVariable('LWristStartVelocityY', 0);
in_zvcf = in_zvcf.setVariable('RWristStartPositionX', rwristPositionX);
in_zvcf = in_zvcf.setVariable('RWristStartVelocityX', 0);
in_zvcf = in_zvcf.setVariable('RWristStartPositionY', rwristPositionY);
in_zvcf = in_zvcf.setVariable('RWristStartVelocityY', 0);


% Ensure logging is configured in the model or via the input object
% in_zvcf = in_zvcf.setLoggingOption('all'); % Example if needed

% --- Run the Simulation ---
fprintf('Running ZVCF simulation at time %g...\n', simTime);
try
    out_zvcf = sim(in_zvcf);
    fprintf('ZVCF simulation complete.\n');
catch ME
    warning('Error running ZVCF simulation at time %g: %s', simTime, ME.message);
    close_system(zvcfModelName, 0); % Close model
    return; % Exit the function
end

% --- Generate Data Table from Output ---
% Assuming generateDataTable3D function is available on the path
try
    zvcfDataTable = generateDataTable3D(out_zvcf);
    % The ZVCF simulation is short (0.05s), so the dataTable will have
    % multiple rows. The original script took the first row (time zero).
    % If you need only the data at the *start* of the ZVCF simulation,
    % you might take the first row here:
    % zvcfDataTable = zvcfDataTable(1,:);
    % And potentially overwrite its time with simTime:
    % zvcfDataTable.Time = simTime;
    % However, if you need the *full* 0.05s of simulation data for this time point,
    % the current approach of returning the full table is correct.
    % Let's return the full table as generateDataTable3D does.
    fprintf('ZVCF data table generated.\n');
catch ME
    warning('Error generating data table from ZVCF output at time %g: %s', simTime, ME.message);
    zvcfDataTable = table(); % Return empty table on error
end


% --- Final Cleanup (Close Model) ---
% Close the ZVCF model if it was opened by this function
% (Only close if it wasn't already loaded when the function started)
% This check is more complex, for simplicity, we'll just close it.
% If performance is critical and you run this function many times,
% consider keeping the model open and using Fast Restart if possible for ZVCF.
% However, ZVCF simulations are short and independent, so closing might be fine.
close_system(zvcfModelName, 0); % Close without saving changes


% No need for explicit 'clear' statements within a function.
% All intermediate variables are local and cleared automatically.

end

%%% END FILE: runZvcfSingleTime.m %%%

%%% START FILE: shelledQuivers3.m %%%
<INSERT CODE FROM CANVAS>

%%% END FILE: shelledQuivers3.m %%%

%%% END OF PACKED PROJECT %%%
